### Overview

* [1 Two Sum](#1-two-sum)
* [2 Add Two Numbers](#2-add-two-numbers)
* [3 Longest Substring Without Repeating Characters](#3-longest-substring-without-repeating-characters)
* [4 Median of Two Sorted Arrays](#4-median-of-two-sorted-arrays)
* [5 Longest Palidromic Substring](#5-longest-palidromic-substring)
* [6 ZigZag Conversion](#6-zigzag-conversion)
* [7 Reverse Integer](#7-reverse-integer)
* [8 String to Integer (atoi)](#8-string-to-integer)
* [9 Palindrome Number](#9-palindrome-number)
* [11 Container With Most Water](#11-container-with-most-water)
* [12 Integer to Roman](#12-integer-to-roman)
* [13 Roman to Integer](#13-roman-to-integer)
* [14 Longest Common Prefix](#14-longest-common-prefix)
* [15 3 Sum](#15-3-sum)
* [16 3 Sum Closet](#16-3-sum-closet)
* [17 Letter Combinations of a Phone Number](#17-letter-combinations-of-a-phone-number)
* [18 4 Sum](#18-4-sum)
* [19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
* [20 Valid Parentheses](#20-valid-parentheses)
* [21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
* [22 Generate Parentheses](#22-generate-parentheses)
* [23 Merge k Sorted Lists](#23-merge-k-sorted-lists)
* [24 Swap Nodes in Pairs](#24-swap-nodes-in-pairs)
* [25 Reverse Nodes in kGroup](#25-reverse-nodes-in-kgroup)
* [26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
* [27 Remove Element](#27-remove-element)
* [28 Implement strStr](#28-implement-strstr)
* [29 Divide Two Integers](#29-divide-two-integers)
* [30 Substring with Concatenation of All Words](#30-substring-with-concatenation-of-all-words)
* [31 Next Permutation](#31-next-permutation)
* [32 Longest Valid Parentheses](#32-longest-valid-parentheses)
* [33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array)
* [34 Search for a Range](#34-search-for-a-range)
* [35 Search Insert Position](#35-search-insert-position)
* [36 Valid Sudoku](#36-valid-sudoku)
* [37 Sudoku Solver](#37-sudoku-solver)
* [38 Count and Say](#38-count-and-say)
* [39 Combination Sum](#39-combination-sum)
* [40 Combination Sum II](#40-combination-sum-ii)
* [41 First Missing Positive](#41-first-missing-positive)
* [42 Trapping Rain Water](#42-trapping-rain-water)
* [43 Multiply Strings](#43-multiply-strings)
* [44 Wildcard Matching](#44-wildcard-matching)
* [45 Jump Game II](#45-jump-game-ii)
* [46 Permutations](#46-permutations)
* [47 Permutations II](#47-permutations-ii)
* [48 Rotate Image](#48-rotate-image)
* [49 Group Anagrams](#49-group-anagrams)
* [50 Pow](#50-pow)
* [51 N Queens](#51-n-queens)
* [52 N Queens II](#52-n-queens-ii)
* [53 Maximum Subarray](#53-maximum-subarray)
* [54 Spiral Matrix](#54-spiral-matrix)
* [55 Jump Game](#55-jump-game)
* [56 Merge Intervals](#56-merge-intervals)
* [57 Insert Interval](#57-insert-interval)
* [58 Length of Last Word](#58-length-of-last-word)
* [59 Spiral Matrix II](#59-spiral-matrix-ii)
* [60 Permutation Sequence](#60-permutation-sequence)
* [61 Rotate List](#61-rotate-list)
* [62 Unique Paths](#62-unique-paths)
* [63 Unique Paths II](#63-unique-paths-ii)
* [64 Minimum Path Sum](#64-minimum-path-sum)
* [65 Valid Number](#65-valid-number)
* [66 Plus One](#66-plus-one)
* [67 Add Binary](#67-add-binary)
* [68 Text Justification](#68-text-justification)
* [69 Sqrt](#69-sqrt)
* [70 Climbing Stairs](#70-climbing-stairs)
* [71 Simplify Path](#71-simplify-path)
* [72 Edit Distance](#72-edit-distance)
* [73 Set Matrix Zeroes](#73-set-matrix-zeroes)
* [74 Search a 2D Matrix](#74-search-a-2d-matrix)
* [75 Sort Colors](#75-sort-colors)
* [76 Minimum Window Substring](#76-minimum-window-substring)
* [77 Combinations](#77-combinations)
* [78 Subsets](#78-subsets)
* [79 Word Search](#79-word-search)
* [80 Remove Duplicates from Sorted Array II](#80-remove-duplicates-from-sorted-array-ii)
* [81 Search in Rotated Sorted Array II](#81-search-in-rotated-sorted-array-ii)
* [82 Remove Duplicates from Sorted List](#82-remove-duplicates-from-sorted-list)
* [83 Remove Duplicates from Sorted List II](#83-remove-duplicates-from-sorted-list-ii)
* [84 Largest Rectangle in Histogram](#84-largest-rectangle-in-histogram)
* [85 Maximal Rectangle](#85-maximal-rectangle)
* [86 Partition List](#86-partition-list)
* [87 Scramble String](#87-sramble-string)
* [89 Gray Code](#89-gray-code)
* [90 Subsets II](#90-subsets-ii)
* [91 Decode Ways](#91-decode-ways)
* [92 Reverse Linked List II](#92-reverse-linked-list-ii)
* [93 Restore IP Addresses](#93-restore-ip-addresses)
* [94 Binary Tree Inorder Traversal](#94-binary-tree-inorder-traversal)
* [95 Unique Binary Search Trees](#95-unique-binary-search-trees)
* [96 Unique Binary Search Trees II](#96-unique-binary-search-trees)
* [97 Interleaving String](#97-interleaving-string)
* [98 Validate Binary Search Tree](#98-validate-binary-search-tree)
* [99 Recover Binary Search Tree](#99-recover-binary-search-tree)
* [100 Same Tree](#100-same-tree)
* [101 Symmetric Tree](#101-symmetric-tree)
* [102 Binary Tree Level Order Traversal](#102-binary-tree-level-order-traversal)
* [103 Binary Tree Zigzag Level Order Traversal](#103-binary-tree-zigzag-level-order-traversal)
* [104 Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-tree)
* [105 Construct Binary Tree from Preorder and Inorder Traversal](#105-construct-binary-tree-from-preorder-and-inorder-traversal)
* [106 Construct Binary Tree from Inorder and Postorder Traversal](#106-construct-binary-tree-from-inorder-and-postorder-traversal)
* [107 Binary Tree Level Order Traversal II](#107-binary-tree-level-order-traversal-ii)
* [108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
* [109 Convert Sorted List to Binary Search Tree](#109-convert-sorted-list-to-binary-search-tree)
* [110 Balanced Binary Tree](#110-balanced-binary-tree)
* [111 Minimum Depth of Binary Tree](#111-minimum-depth-of-binary-tree)
* [112 Path Sum](#112-path-sum)
* [113 Path Sum II](#113-path-sum-ii)
* [114 Flatten Binary Tree to Linked List](#114-flatten-binary-tree-to-linked-list)
* [115 Distinct Subsequences](#115-distinct-subsequences)
* [116 Populating Next Right Pointers in Each Node](#116-populating-next-right-pointers-in-each-node)
* [117 Populating Next Right Pointers in Each Node II](#117-populating-next-right-pointers-in-each-node-ii)
* [118 Pascal Triangle](#118-pascal-triangle)
* [119 Pascal Triangle II](#119-pascal-triangle-ii)
* [120 Triangle](#120-triangle)
* [121 Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
* [122 Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
* [123 Best Time to Buy and Sell Stock III](#123-best-time-to-buy-and-sell-stock-iii)
* [124 Binary Tree Maximum Path Sum](#124-binary-tree-maximum-path-sum)
* [125 Valid Palindrome](#125-valid-palindrome)
* [126 Word Ladder](#126-word-ladder)
* [127 Word Ladder II](#127-word-ladder-ii)
* [128 Longest Consecutive Sequence](#128-longest-consecutive-sequence)
* [129 Sum Root to Leaf Numbers](#129-sum-root-to-leaf-numbers)
* [130 Surrounded Regions](#130-Surrounded-regions)
* [131 Parlindrome partitioning](#131-parlindrome-partitioning)
* [132 Parlindrome partitioning II](#132-parlindrome-partitioning-ii)
* [133 Clone Graph](#133-clone-graph)
* [134 Gas Station](#134-gas-station)
* [135 Candy](#135-candy)
* [136 Single Number](#136-single-number)
* [137 Single Number II](#136-single-number-ii)
* [138 Copy List With Random Pointer](#138-copy-list-with-random-pointer)
* [139 Word Break](#139-word-break)
* [140 Word Break II](#140-word-break-ii)
* [141 Linked List Cycle](#141-linked-list-cycle)
* [142 Linked List Cycle II](#142-linked-list-cycle-ii)
* [143 Reorder List](#143-reorder-list)
* [144 Binary Tree Preorder Traversal](#144-binary-tree-preorder-traversal)
* [145 Binary Tree Postorder Traversal](#145-binary-tree-postorder-traversal)
* [146 LRU Cache](#146-lru-cache)
* [147 Insertion Sort List](#147-insertion-sort-list)
* [148 Sort List](#148-sort-list)
* [149 Max Points on a Line](#149-max-points-on-a-line)
* [150 Evaluate Reverse Polish Notation](#150-Evaluate-Reverse-Polish-Notation)
* [151 Reverse Words in a String](#151-reverse-words-in-a-string)
* [152 Maximum Product Subarray](#152-maximum-product-subarray)
* [153 Find Minimum in Rotated Sorted Array](#153-find-minimum-in-rotated-sorted-array)
* [154 Find Minimum in Rotated Sorted Array II](#154-find-minimum-in-rotated-sorted-array-ii)
* [155 Min Stack](#155-min-stack)
* [156 Binary Tree Upside Down](#156-binary-tree-upside-down)
* [157 Read N Characters Given Read4](#157-read-n-characters-given-read4)
* [158 Read N Characters Given Read4 II - Call multiple times](#158-read-n-characters-given-read4-ii-call-multiple-times) 
* [159 Longest String with At Most Two Distinct Characters](#159-longest-string-with-at-most-two-distinct-characters)
* [160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)
* [161 One edit distance](#161-one-edit-distance)
* [162 Find Peak Element](#162-find-peak-element)
* [163 Missing Ranges](#163-missing-ranges)
* [164 Maximum Gap](#164-maximum-gap)
* [165 Compare Version Numbers](#165-compare-version-numbers)
* [166 Fraction to Recurring Decimal](#166-fraction-to-recurring-decimal)
* [167 Two Sum II Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
* [168 Excel Sheet Column Title](#168-excel-sheet-column-title)
* [169 Majority Element](#169-majority-element)
* [170 Two Sum III Data Structure Design](#170-two-sum-iii-data-structure-design)
* [171 Excel Sheet Column Number](#171-excel-sheet-column-number)
* [172 Factorial Trailing zeros](#172-factorial-trailing-zeros)
* [173 Binary Search Tree Iterator](#173-binary-search-tree-iterator)
* [174 Dungeon Game](#174-dungeon-game)
* [179 Largest Number](#179-largest-number)
* [186 Reverse Words in a String II](#186-reverse-words-in-a-string-ii)
* [187 Repeated DNA Sequences](#187-repeated-dna-sequences) 
* [188 Best Time to Buy and Sell Stock IV](#188-best-time-to-buy-and-sell-stock-iv)
* [189 Rotate Array](#189-rotate-array)
* [190 Reverse Bits](#190-reverse-bits)
* [191 Number of 1 Bits](#191-number-of-1-bits)
* [198 House Robber](#198-house-robber)
* [199 Binary Tree Right Side View](#199-binary-tree-right-side-view)
* [200 Number of Islands](#200-number-of-islands)
* [201 Bitwise AND of Numbers Range](#201-bitwise-and-of-numbers-range)
* [202 Happy Number](#202-happy-number)
* [203 Remove Linked List Elements](#203-remove-linked-list-elements)
* [204 Count Primes](#204-count-primes)
* [205 Isomorphic Strings](#205-isomorphic-strings)
* [206 Reverse Linked List](#206-reverse-linked-list)
* [207 Course Schedule](#207-course-schedule)
* [208 Implement Trie Prefix Tree](#208-implement-trie-prefix-tree)
* [209 Minimum Size Subarray Sum](#209-minimum-size-subarray-sum)
* [210 Course Schedule II](#210-course-schedule-ii)
* [211 Add and Search Word Data structure design](#211-add-and-search-word-data-structure-design)
* [212 Word Search II](#212-word-search-ii)
* [213 House Robber II](#213-house-robber-ii)
* [214 Shortest Palindrome](#214-shortest-palindrome)
* [215 Kth Largest Element in an Array](#215-kth-largest-element-in-an-array)
* [216 Combination Sum III](#216-combination-sum-iii)
* [217 Contains Duplicate](#217-contains-duplicates)
* [218 The Skyline Problem](#218-the-skyline-problem)
* [219 Contains Duplicate II](#219-contains-duplicates-ii)
* [220 Contains Duplicate III](#220-contains-duplicates-iii)
* [221 Maximal Square](#221-maximal-square)
* [222 Count Complete Tree Nodes](#222-count-complete-tree-nodes)
* [223 Rectangle Area](#223-rectangle-area)
* [224 Basic Calculator](#224-basic-calculator)
* [225 Implement Stack using Queues](#225-implement-stack-using-queues)
* [226 Invert Binary Tree](#226-invert-binary-tree)
* [227 Basic Calculator II](#227-basic-calculator-ii)
* [228 Summary Ranges](#228-summary-ranges)
* [229 Majority Element II](#229-majority-element-ii)
* [230 Kth Smallest Element in a BST](#230-kth-smallest-element-in-a-bst)
* [231 Power of Two](#231-power-of-two)
* [232 Implement Queue using Stacks](#232-implement-queue-using-stacks)
* [233 Number of Digit One](#233-number-of-digit-one)
* [234 Palindrome Linked List](#234-palindrome-linked-list)
* [235 Lowest Common Ancestor of a Binary Search Tree](#235-lowest-common-ancestor-of-a-binary-search-tree)
* [236 Lowest Common Ancestor of a Binary Tree](#236-lowest-common-ancestor-of-a-binary-tree)
* [237 Delete Node in a Linked List](#237-delete-node-in-a-linked-list)
* [238 Product of Array Except Self](#238-product-of-array-except-self)
* [239 Sliding Window Maximum](#239-sliding-window-maximum)
* [240 Search a 2D Matrix II](#240-search-a-2d-matrix-ii)
* [241 Different Ways to Add Parentheses](#241-different-ways-to-add-parentheses)
* [242 Valid Anagram](#242-Valid Anagram)
* [243 Shortest Word Distance](#243-shortest-word-distance)
* [244 Shortest Word Distance II](#244-shortest-word-distance-ii)
* [245 Shortest Word Distance III](#245-shortest-word-distance-iii)
* [246 Strobogrammatic Number](#246-strobogrammatic-number)
* [247 Strobogrammatic Number](#247-strobogrammatic-number-ii)
* [248 Strobogrammatic Number](#248-strobogrammatic-number-iii)
* [249 Group Shifted Strings](#249-group-shifted-strings)
* [250 Count Univalue Subtrees](#250-count-univalue-subtrees)
* [251 Flatten 2D Vector](#251-flatten-2d-vector)
* [252 Meeting Rooms](#252-meeting-rooms)
* [253 Meeting Rooms II](#253-meeting-rooms-ii)
* [254 Factor Combinations](#254-factor-combinations)
* [255 Verify Preorder Sequence in Binary Search Tree](#255-verify-preorder-sequence-in-binary-search-tree)
* [256 Paint House](#256-paint-house)
* [257 Binary Tree Paths](#257-binary-tree-paths)
* [258 Add Digits](#258-add-digits)
* [259 3Sum Smaller](#259-3sum-smaller)
* [260 Single Number III](#260-single-number-iii)
* [261 Graph Valid Tree](#261-graph-valid-tree)
* [263 Ugly Number](#263-ugly-number)
* [264 Ugly Number II](#264-ugly-number-ii)
* [265 Paint House II](#265-paint-house-ii)
* [266 Palindrome Permutation](#266-palindrome-permutation)
* [267 Palindrome Permutation II](#267-palindrome-permutation-ii)
* [268 Missing Number](#268-missing-number)
* [269 Alien Dictionary](#269-alien-dictionary)
* [270 Closest Binary Search Tree Value](#270-Closest Binary Search Tree Value)
* [271 Encode and Decode Strings](#271-encode-and-encode-strings)
* [272 Closest Binary Search Tree Value II](#270-Closest Binary Search Tree Value II)
* [273 Integer to English Words](#273-integer-to-english-words)
* [274 H-Index](#274-h-index)
* [275 H-Index II](#275-h-index-ii)
* [276 Paint Fence](#276-Paint-fence)
* [277 Find the Celebrity](#277-find-the-celebrity)
* [278 First Bad Version](#278-first-bad-version)
* [279 Perfect Squares](#279-perfect-squares)
* [280 Wiggle Sort](#280-wiggle-sort)
* [281 Zigzag Iterator](#281-zigzag-iterator)
* [282 Expression Add Operators](#282-expression-add-operators)
* [283 Move Zeroes](#283-move-zeroes)
* [284 Peeking Iterator](#284-peeking-iterator)
* [285 Inorder Successor in BST](#285-inorder0-successor-in-bst)
* [286 Walls and Gates](#286-walls-and-gates)
* [287 Find the Duplicate Number](#287-find-the-duplicate-number)
* [288 Unique Word Abbreviation](#288-unique-word-abbreviation)
* [289 Game of Life](#289-game-of-life)
* [290 Word Pattern](#290-word-pattern)
* [291 Word Pattern II](#291-word-pattern-ii)
* [292 Nim Game](#292-nim-game)
* [293 Flip Game](#293-flip-game)
* [294 Flip Game II](#294-flip-game)
* [295 Find Median from Data Stream](#295-find-median-from-data-stream)
* [296 Best Meeting Point](#296-best-meeting-point)
* [297 Serialize and Deserialize Binary Tree](#297-serialize-and-deserialize-binary-tree)
* [298 Binary Tree Longest Consecutive Sequence](#298-binary-tree-longest-consecutive-sequence)
* [299 Bulls and Cows](#299-bulls-and-cows)
* [300 Longest Increasing Subsequence](#300-longest-increasing-subsequence)
* [301 Remove Invalid Parentheses](#301-remove-invalid-parentheses)
* [302 Smallest Rectangle Enclosing Black Pixels](#302-smallest-rectangle-enclosing-black-pixels)
* [303 Range Sum Query Immutable](#303=range-sum-query-immutable)
* [304 Range Sum Query 2D Immutable](#304-range-sum-query-2d-immutable)
* [305 Number of Islands II](#305-number-of-islands-ii)
###Others
* [1 Fibonacci](#1-fibonacci)
* [2 Binary Search Template](#2-binary-search-template)
* [3 Merge Sort](#3-merge-sort)
* [4 Quick Sort](#4-quick-sort)

<br>
### <a name="1-two-sum"></a>1 Two Sum


>Given an array of integers, find two numbers such that they add up to a specific target number.

>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

>You may assume that each input would have exactly one solution.

>Input: numbers={2, 7, 11, 15}, target=9

>Output: index1=1, index2=2

**Idea**: Use HashMap to record the number one by one and check if it exist the target at the same time, only use one loop.

**Time Complexity** O(n)

**Space Complexity** O(n)

**Tags** HashMap

***C++ Code***
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> mp;
        vector<int> result;
        for (int i = 0;i < nums.size();i++) {
            if (mp.count(target-nums[i])>0) {
                result.push_back(mp[target - nums[i]]);
                result.push_back(i + 1);
                return result;
            }
            mp[nums[i]] = i + 1;
        }
    }
};
```

**C# Code**:
```C#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Hashtable book = new Hashtable();
        int[] result = new int[2];
        for(int i = 0; i < nums.Length; i++){
            if (book.ContainsKey(target - nums[i])){
                result[0] = (int)book[target - nums[i]];
                result[1] = i + 1;
                return result;
            }
            if (book.ContainsKey(nums[i])){
                book[nums[i]] = i + 1;
            }
            else{
                book.Add(nums[i], i + 1);
            }
        }
        return null;
    }
}
```
<br>

### <a name="2-add-two-numbers"></a>2 Add Two Numbers
> You are given two linked lists representing two non-negative numbers.
> The digis are stored in reverse order and each of their nodes contain a single digit.
> Add the two numbers and return it as a linked list.
>
> **`Input:`** `(2 -> 4 -> 3) + (5 -> 6 -> 4)`
>
> **`Output:`** `(7 -> 0 -> 8)`

**Idea**

Digits are stored in reverse order, that means `(2 -> 4 -> 3)` is `342`. When it reaches 10 after addition, the next node shall add 1 and current node shall only keep the unit number: `(3 -> 2) + (9 -> 1) = (2 -> 4)`; if one integer doesn't have more numbers, add the remaining digits to  result.

**Attention**: After both l1 and l2 reach to the end, check the carry. If carry != 0, add an additional node to the result. 



**C++ Code**
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if(l1 == NULL) return l2;
        if(l2 == NULL) return l1;
        ListNode *l3 = new ListNode(0);
        ListNode *p = l3;
        int carry = 0;
        while (l1 && l2) {
            int sum = l1->val + l2->val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            p->next = new ListNode(mod);
            p = p->next;
            l1 = l1->next;
            l2 = l2->next;
        }
        while (l1) {
            int sum = l1->val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            p->next = new ListNode(mod);
            p = p->next;
            l1 = l1->next;
        }
        while (l2) {
            int sum = l2->val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            p->next = new ListNode(mod);
            p = p->next;
            l2 = l2->next;
        }
        if (carry > 0)
        p->next = new ListNode(carry);
        return l3->next;
    }
};
```

***C# Code***
```c#
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     public int val;
 *     public ListNode next;
 *     public ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;
        ListNode l3 = new ListNode(0);
        ListNode p = l3;
        int carry = 0;
        while (l1 != null && l2 != null) {
            int sum = l1.val + l2.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            p.next = new ListNode(mod);
            p = p.next;
            l1 = l1.next;
            l2 = l2.next;
        }
        while (l1 != null) {
            int sum = l1.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            p.next = new ListNode(mod);
            p = p.next;
            l1 = l1.next;
        }
        while (l2 != null) {
            int sum = l2.val + carry;
            int mod = sum % 10;
            carry = sum / 10;
            p.next = new ListNode(mod);
            p = p.next;
            l2 = l2.next;
        }
        if (carry > 0)
        p.next = new ListNode(carry);
        return l3.next;
    }
}
```

<br>

### <a name="3-longest-substring-without-repeating-characters"></a>3 Longest Substring Without Repeating Characters
> Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.

**Idea**

首先，这是个求最值的题，考虑dp。

遍历一遍字符串，每当遇到重复字符时便将start置为之前出现的这个字符的位置+1。

在每一次操作中都记录下下标位置，以便在之后重复时找到位置。

在每一次操作中比较目前长度和maxlen的大小，取最大值。

***C++ Code***
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector<int> dp(256, -1);
        int result = 0, start = 0;
        for (int i = 0;i < s.length();i++) {
            if (dp[s[i]] >= start) start = dp[s[i]]+1;
            dp[s[i]] = i;
            result = max(result, i-start+1);
        }
        return result;
    }
};
```

***C# Code***
```C#
public class Solution {
    public int LengthOfLongestSubstring(string s) {
        int[] dp = new int[256];
        for (int i = 0;i < 256;i++) {
            dp[i] = -1;
        }
        int result = 0, start = 0;
        for (int i = 0;i < s.Length;i++) {
            if (dp[s[i]] >= start) start = dp[s[i]]+1;
            dp[s[i]] = i;
            result = Math.Max(result, i-start+1);
        }
        return result;
    }
}
```
<br>

### <a name="4-median-of-two-sorted-arrays"></a>4 Median of Two Sorted Arrays
> There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

**Idea**

将找中位数问题=>泛化成找两个数列中第k大的数：

1. 比较两个数列的中间数大小

2. 若a[mid] <= b[mid] then return findKth(a+mid+1, m-mid-1, b, n, k-mid-1);

3. 若a[mid] >  b[mid] then return findKth(a, m, b+mid+1, n-mid-1,k-mid-1);

在每次findKth时，判断m是否为0以及k是否为1。
并且每次控制a串比b串短

***C++ Code***
```C++
class Solution {
public:
    double findKthElement(vector<int>::iterator a,int m,vector<int>::iterator b,int n,int k) {
        if (m > n) return findKthElement(b,n,a,m,k);
        if (m == 0) return b[k-1];
        if (k == 1) return min(a[0],b[0]);
        int mid_a = min(k/2,m);
        int mid_b = k - mid_a;
        if (a[mid_a-1] <= b[mid_b-1]) return findKthElement(a + mid_a,m - mid_a,b,n,k-mid_a);
        else return findKthElement(a,m,b+mid_b,n-mid_b,k-mid_b);
    }
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        auto a = nums1.begin();
        auto b = nums2.begin();
        int m = nums1.size();
        int n = nums2.size();
        int len = nums1.size() + nums2.size();
        if (len % 2 == 0) return 0.5*(findKthElement(a,m,b,n,len/2) + findKthElement(a,m,b,n,len/2+1));
        else return findKthElement(a,m,b,n,len/2+1);
    }
};
```

***C# Code***
```C#

```

### <a name="5-longest-palidromic-substring"></a>5 Longest Palidromic Substring
> Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.


### <a name="6-zigzag-conversion">6 ZigZag Conversion

> The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

<pre>
P   A   H   N
A P L S I I G
Y   I   R
</pre>

> And then read line by line: "PAHNAPLSIIGYIR"
Write the code that will take a string and make this conversion given a number of rows:

<pre>
string convert(string text, int nRows);
</pre>

> convert("PAYPALISHIRING", 3) should return "PAHNAPLSIIGYIR".

**Idea**

这种题找不到头绪可以找规律，从nRows = 3, nRows = 4, nRows = 5画出来能发现两个通式：

1. 第一行和最后一行，每列相隔 2 * (nRows - 1)

2. 中间的行，交替出现 2 * (nRows - i - 1) 和 2 * i

然后只要两个for循环，一个走行一个走列即可

***C++ Code***
```C++
class Solution{
public:
    string convert(string s, int numRows){
        string result;
        if (numRows == 1) return s;
        for (int i = 0;i < numRows;++i) {
            bool flag = true;
            for (int j = i;j < s.length();) {
                result.push_back(s[j]);
                if (i == 0 || i == numRows-1) {
                    
                    j += 2*(numRows - 1);
                }
                else {
                    if (flag) {
                        j += 2*(numRows - i - 1);
                    }
                    else {
                        j += 2*i;
                    }
                    flag = !flag;
                }
            }
        }
        return result;
    }
};
```

***C# Code***
```C#
public class Solution {
    public string Convert(string s, int numRows) {
        string result = "";
        if (s.Length == 1 || numRows == 1) return s;
        for (int i = 0;i < numRows;++i) {
            bool flag = true;
            for (int j = i;j < s.Length;) {
                result += s[j];
                if (i == 0 || i == numRows-1) {
                    j += 2 * (numRows - 1);
                }
                else {
                    if (flag) {
                        j += 2 * (numRows - i - 1);
                    }
                    else {
                        j += 2 * i;
                    }
                    flag = !flag;
                }
            }
        }
        return result;
    }
}
```

### <a name = "7-reverse-integer">7 Reverse Integer
> Reverse digits of an integer.

> ***Example1:*** x = 123, return 321

> ***Example2:*** x = -123, return -321

**Attention:** Watch out the case of overflow,  Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?

For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

**Idea**

从最简单的反转123考虑，每一次保留个位数加入新数做累积累加 result = result*10 + mod;

1.考虑第一个问题：负号，实际上不用考虑 -321 = -3*100 + -2*10 + -1
2.考虑第二个went：溢出，若溢出，那么溢出的结果 /10 一定不能复原，因此每次都保存temp 验证result/10 == temp? 即可

***C++ Code***
```C++
class Solution {
public:
    int reverse (int n) {
        int result = 0;
        int mod = 0;
        int temp = 0;
        while (n){
            mod = n % 10;
            temp = result;
            result = result * 10 + mod;
            if (result / 10 != temp) return 0;
            n /= 10;
        }
        return result;
    }
};
```

***C# Code***
```C#
public class Solution {
    public int Reverse(int x) {
        int result = 0;
        int mod = 0;
        int temp = 0;
        while (x != 0){
            mod = x % 10;
            temp = result;
            result = result * 10 + mod;
            if (result / 10 != temp) return 0;
            x /= 10;
        }
        return result;
    }
}
```

###<a name = "8-string-to-integer">8 String to Integer (atoi)
> Implement atoi to convert a string to an integer.

> ***Hint:*** Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

> ***Notes:*** It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.

**Idea**

***C++ Code Solution 1 using istringstream***
```C++
class Solution {
public:
    int myAtoi(string str) {
        if (str=="") return 0;
        istringstream iss(str);
        int a;
        iss>>a;
        return a;
    }
};
```

###<a name = "9-palindrome-number">9 Palindrome Number
> Determine whether an integer is a palindrome. Do this without extra space.

**Idea**
* Solution 1: I used a string to store this int, and check the head and tail if they are the same, otherwise report false. But it will use O(n) space complexity.

* Solution 2: I used the reverse integer function to check it, but it will not handle the overflow case although it can still pass the OJ.

* Solution 3: I follow the thought from solution 1 without construct a string, only use two pointers.

***C++ Code Solution 1***
```C++
class Solution1 {
public:
    bool isPalindrome(int x) {
        if (x<0) return false;
        string str = to_string(x);
        int n = (int)str.length();
        int i = 0;
        while (i < n/2) {
            if (str[i] != str[n-i-1]) return false;
            i++;
        }
        return true;
    }
};
```

***C++ Code Solution 2***
```C++
class Solution2 {
public:
    bool isPalindrome(int x) {
        if (x<0) return false;
        int result = 0;
        int mod = 0;
        int save = x;
        while (x) {
            mod = x % 10;
            result = result * 10 + mod;
            x /= 10;
        }
        return result == save;
    }
};
```

***C++ Code Solution 3***
```C++
class Solution3 {
public:
    bool isPalindrome(int x) {
        if (x<0) return false;
        int temp = x;
        int digit = 1;
        while (temp >= 10) {
            digit *= 10;
            temp /= 10;
        }
        while (x) {
            int left = x / digit;
            int right = x % 10;
            if (left != right) return false;
            x = (x % digit) / 10;
            digit /= 100;
        }
        
        return true;
    }
};
```

###<a name = "11-container-with-most-water"></a>11 Container With Most Water

> Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

> ***Note:*** You may not slant the container.

**Idea**
Greedy Algorithm, start from the outer two pointers, and compare the height, move the pointer which is smaller.

***C++ Code***
```C++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0;
        int j = height.size() - 1;
        int result = 0;
        while (i < j) {
            result = max(result, min(height[i],height[j])*(j-i));
            if (height[i] < height[j]) i++;
            else j--;
        }
        return result;
    }
};
```

***C# Code***
```C#
public class Solution {
    public int MaxArea(int[] height) {
        int i = 0;
        int j = height.Length - 1;
        int result = 0;
        while (i < j) {
            result = Math.Max(result, Math.Min(height[i],height[j])*(j-i));
            if (height[i]<height[j]) i++;
            else j--;
        }
        return result;
    }
}
```

###<a name=""12-integer-to-roman></a>12 Integer to Roman

> Given an integer, convert it to a roman numeral.

> Input is guaranteed to be within the range from 1 to 3999.

**Idea** 找规律填数字，每次循环注意digit分为四种情况即可: <1-3>,<4>,<5-8>,<9>

***C++ Code***
```C++
class Solution {
public:
    string intToRoman(int num) {
        string result;
        vector<char> roman = {'M','D','C','L','X','V','I'};
        int t = num / 1000 + 1;
        num = t>0 ? num%1000 : t;
        while (--t) {
            result += roman[0];
        }
        int flag = 100;
        for (int i = 0;i < 3;i++,flag /= 10) {
            if (num < flag) continue;
            int digit = num / flag;
            if (digit == 9) {
                result = result + roman[2*i+2]+ roman[2*i];
            }
            else if (digit >= 5) {
                result = result + roman[2*i+1];
                while (--digit >= 5) {
                    result = result + roman[2*i+2];
                }
            }
            else if (digit == 4) {
                result = result + roman[2*i+2] + roman[2*i+1];
            }
            else {
                while (--digit >= 0) {
                    result = result + roman[2*i+2];
                }
            }
            num %= flag;
        }
        return result;
    }
};
```

###<a name="13-roman-to-integer"></a>13 Roman to Integer

> Given a roman numeral, convert it to an integer.

> Input is guaranteed to be within the range from 1 to 3999.

**Idea** 
* 先将罗马数字映射进map，注意map的initialization, pair可以直接用{ }初始化。
* 遍历字符串，分为三种情况，一种前比后大直接加，一种前比后小要减去，一种前后相等要累积 之后才能判断加减。
* 用一个temp数字来保存之前相等的累计数。

***C++ Code***

```C++
class Solution {
public:
    int romanToInt(string s) {
        int result = 0;
        unordered_map<char, int> mp = {{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
        int temp = 0;
        for (int i = 0;i < s.length() - 1;i++) {
            if (mp[s[i]] == mp[s[i+1]]) temp += mp[s[i]];
            else if (mp[s[i]] > mp[s[i+1]]) {
                result = result + temp + mp[s[i]];
                temp = 0;
            }
            else {
                result = result - temp - mp[s[i]];
                temp = 0;
            }
        }
        result += mp[s[s.length()-1]] + temp;

        return result;
    }
};
```

###<a name = "14-longest-common-prefix">14 Longest Common Prefix

> Write a function to find the longest common prefix string amongst an array of strings.

**Idea** Compare every character in all strings.

***C++ Code***
```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (strs.size() == 0) return "";
        if (strs.size() == 1) return strs[0];
        string result = "";
        for (int i = 0;i < strs[0].length();i++) {
            char check = strs[0][i];
            for (int j = 0;j < strs.size();j++) {
                if (check != strs[j][i] || i == strs[j].length()) return result;
            }
            result += check;
        }
        return result;
    }
};
```

***C# Code***
```C#
public class Solution {
    public string LongestCommonPrefix(string[] strs) {
        if (strs.Length == 0) return "";
        if (strs.Length == 1) return strs[0];
        string result = "";
        for (int i = 0;i < strs[0].Length;i++) {
            char check = strs[0][i];
            for (int j = 0;j < strs.Length;j++) {
                if (i == strs[j].Length || check != strs[j][i] ) return result;
            }
            result += check;
        }
        return result;
    }
}
```

###<a name = "15-3-sum"></a>15 3 Sum

> Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

- Elements in a triplet (a,b,c) must be in **non-descending order**. (ie, a ≤ b ≤ c)

- The solution set **must not contain duplicate triplets**.
    
    
    
  		For example, given array S = {-1 0 1 2 -1 -4},
    	A solution set is:
    	(-1, 0, 1)
    	(-1, -1, 2)
    

**Idea** 
* At first, we can think of the naive implemention with O(n^3): brute force
* Then we can select one number as -target, then travese using hashmap (Two Sum)
* However, we found the requirments that in non-descending order, so we should sort at first, but when dealing sorted array we can use two pointer method rather than hashmap, which can save the space complexity.
* Watch out for duplicates. I added three lines to keep the three number from duplicates.


***C++ Code
```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        if (nums.size() < 3) return result;
        sort(nums.begin(),nums.end());
        for (int i = 0;i < nums.size() - 2;i++) {
            if(i>0 && nums[i] == nums[i-1]) continue;                //In case of duplicates
            int target = - nums[i];
            int start = i + 1;
            int end = nums.size() - 1;
            while (start < end) {
                if (nums[start] + nums[end] == target) {
                    vector<int> line({nums[i],nums[start],nums[end]});
                    result.push_back(line);
                    start++;
                    end--;
                    while (nums[start] == nums[start-1]) start ++;  //In case of duplicates
                    while (nums[end]==nums[end+1]) end--;           //In case of duplicates
                }
                else if (nums[start] + nums[end] > target) end--;
                else start++;
            }
        }
        return result;
    }
};
```

###<a name="3-sum-closet"></a>16 3 Sum Closet

> Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

- For example, given array S = {-1 2 1 -4}, and target = 1.

- The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

**Idea** Just follow the 3 Sum to find the closet

***C++ Code***
```C++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int distance = INT32_MAX;
        int result = 0;
        if (nums.size() < 3) return 0;
        sort(nums.begin(),nums.end());
        for (int i = 0;i < nums.size()-2;i++) {
            int newtarget = target - nums[i];
            int start = i+1;
            int end = nums.size()-1;
            while (start < end) {
                if (abs(newtarget - nums[start] - nums[end]) < distance) {
                    distance = abs(newtarget - nums[start] - nums[end]);
                    result = nums[start] + nums[end] + nums[i];
                }
                if (distance == 0) return target;
                else if (nums[start] + nums[end] > newtarget) end--;
                else start++;
            }
        }
        return result;
    }
};
```

###<a name = "17-letter-combinations-of-a-phone-number"></a>17 Letter Combinations of a Phone Number

>  Given a digit string, return all possible letter combinations that the number could represent.

> A mapping of digit to letters (just like on the telephone buttons) is given below.

<pre>

Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

</pre>

> Note:

> Although the above answer is in lexicographical order, your answer could be in any order you want.

**Idea** Backtracking

backtracking的标准写法: 

- 写一个helper，helper第一个部分判断是否combinations完毕，是的话return

- 第二个部分添加push_back这个字符，执行本函数并将位置加一，再pop_back之前那个字符

**Complexity**
O(k ^ n), k is possible choice of each digit, n is the length of digits

***C++ Code***
```C++
class Solution {
public:
    void letterCombinationsHelper(vector<string> &result, vector<string> letters,string digits, string &line, int start) {
        if (start == digits.length()) {
            result.push_back(line);
            return;
        }
        for (int i = 0;i < letters[digits[start]-'0'].length();i++) {
            line.push_back(letters[digits[start]-'0'][i]);
            letterCombinationsHelper(result,letters,digits,line,start+1);
            line.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        vector<string> result;
        vector<string> letters({"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"});
        string line = "";
        if (digits.length() == 0) return result;
        letterCombinationsHelper(result,letters,digits,line,0);
        return result;
    }
};
```

###<a name="18-4-sum">18 4 Sum

>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

>Note:

- Elements in a quadruplet (a,b,c,d) must be in **non-descending order**. (ie, a ≤ b ≤ c ≤ d)

- The solution set must **not contain duplicate quadruplets**.
 
 
 For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

        A solution set is:
   	    (-1,  0, 0, 1)
        (-2, -1, 1, 2)
        (-2,  0, 0, 2)
    
<br>

**Idea** Like 3 sum, still be carefull for duplicates with 4 individual number;

**Complexity** Time O(n^3) Space O(n^2)

```C++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> result;
    if (nums.size() < 4) return result;
    sort(nums.begin(),nums.end());
    for (int i = 0;i < nums.size() - 3;i++) {
        if (i > 0 && nums[i] == nums[i-1]) continue;
        for (int j = i + 1;j < nums.size() - 2;j++) {
            if (j>i+1 && nums[j] == nums[j-1]) continue;
            int newtarget = target - nums[i] - nums[j];
            int start = j + 1;
            int end = (int)nums.size() - 1;
            while (start < end) {
                if (nums[start] + nums[end] == newtarget) {
                    vector<int> line({nums[i],nums[j],nums[start],nums[end]});
                    result.push_back(line);
                    start ++;
                    end--;
                    while (nums[start] == nums[start-1]) start++;
                    while (nums[end] == nums[end+1]) end--;
                }
                else if (nums[start] + nums[end] > newtarget) end--;
                else start++;
            }
        }
    }
    return result;
}
};
```

###<a name="19-remove-nth-node-from-end-of-list"></a>19 Remove Nth Node From End of List

Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.

***Note:***

Given n will always be valid.
Try to do this in one pass.

**Idea** Create a fast node which is n step fast than head, and for corner case i would advise use dummynode.

***C++***
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode dummynode(0);
        dummynode.next = head;
        ListNode *fast = head;
        while (n--) {
            fast = fast->next;
        }
        head = &dummynode;
        while (fast) {
            head = head->next;
            fast = fast->next;
        }
        head->next = head->next->next;
        return dummynode.next;
    }
};
```

###<a name="20-valid-parentheses"></a>20 Valid Parentheses

> Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

> The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

**Idea** Use a stack, and in the loop, judge the top of stack whether it matches the current bracket.

***C++ Code***
```C++
class Solution {
public:
    bool isValid(string s) {
        stack<char> ss;
        for (int i = 0;i < s.length();i++) {
            if (s[i] == '(' || s[i] == '{' || s[i] == '[') ss.push(s[i]);
            else {
                if (s[i] == ')') {
                    if (ss.empty() || ss.top() != '(') return false;
                    ss.pop();
                }
                
                else if (s[i] == '}') {
                    if (ss.empty() || ss.top() != '{') return false;
                    ss.pop();
                }
                
                else if (s[i] == ']') {
                    if (ss.empty() || ss.top() != '[') return false;
                    ss.pop();
                }
            }
        }
        return ss.empty();
    }
};
```

###<a name="21-merge-two-sorted-lists"></a>21 Merge Two Sorted Lists

> Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**Idea** Naive implemetion by creating a new list node, be careful for dummynode.

***C++ Code ***
```C++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode dummynode(0);
        ListNode *l3 = &dummynode;
        while (l1 && l2) {
            if (l1->val <= l2->val) {
                l3->next = l1;
                l1 = l1->next;
            }
            else { 
                l3->next = l2; 
                 l2 = l2->next;
            }
            l3 = l3->next;
        }
        if (l1) l3->next = l1;
        else l3->next = l2;
        return dummynode.next;
    }
};
```

###<a name="22-generate-parantheses"></a>22 Generate Parentheses

> Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

> For example, given n = 3, a solution set is:

        "((()))", "(()())", "(())()", "()(())", "()()()"

**Idea** Backtracking
It's like combination, for example of 3, it's like combinations of (),(),(),(),(),() but it has constraint.

You should first add '(' and the count of ')' never exceed count of '('.

Then in the helper function: 

we can consider the combination of "((()))", and use left right pointer for constraint.

Then follow the normal backtracking method to fill the function, be care to replace for loop with two if clause.

***C++ Code***
```C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        string line;
        int count = n;
        int left = 0, right = 2*n - 1;
        generate(result,line,left,right,count);
        return result;
    }
    void generate(vector<string> &result, string &line, int left, int right,int x)
    {
        if (left > right) {
            result.push_back(line);
            return;
        }
        if (left < x) {
            line.push_back('(');
            generate(result,line,left+1,right,x);
            line.pop_back();
        }
        if (2*x - right - 1 < left){
            line.push_back(')');
            generate(result,line,left,right-1,x);
            line.pop_back();
        }
    }
};
```

###<a name="24-swap-nodes-in-pairs"></a>24 Swap Nodes in Pairs
> Given a linked list, swap every two adjacent nodes and return its head.

> For example,

> Given 1->2->3->4, you should return the list as 2->1->4->3.

> Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

**Idea** Swap one by one, remember using dummy node;

***C++***

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == NULL || head->next ==NULL) return head;
        ListNode dummy(-1);
        ListNode* temp = &dummy;
        while (head && head->next) {
            temp->next = head->next;   //these three lines are used to swap sequence
            head->next = head->next->next;
            temp->next->next = head;
            
            temp = head;               // these two lines are used to move forward
            head = head->next;
        }
        temp->next = head;
        return dummy.next;
    }
};
```

###<a name="26-remove-duplicates-from-sorted-array"></a>26 Remove Duplicates from Sorted Array

> Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

> Do not allocate extra space for another array, you must do this in place with constant memory.

> For example,

> Given input array nums = [1,1,2],

> Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter 
 
> what you leave beyond the new length.

**Idea**

***C++ Solution 1 using dynamic vector***
```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0;
        int count = 1;
        for (int i = 1,n = 1;n < nums.size();n++) {
            if (nums[i] == nums[i-1]) {
                int temp = nums[i];
                nums.erase(nums.begin()+i);
                nums.push_back(temp);
            }
            else {
                ++count;
                ++i;
            }
        }
        return count;
    }
};
```

***C++ Solution 2 using normal arrays*** 
```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) return 0;
        int count = 1;
        for (int i = 1,p = 1;i < nums.size();i++) {      //Two Pointers to store the current index and should store index
            while (nums[i] == nums[i-1]) i++;
            if (i< nums.size()) {
                nums[p] = nums[i];
                count++;
                p++;
            }
        }
        return count;
    }
};
```

###<a name=""27-remove-element></a>27 Remove Element

> Given an array and a value, remove all instances of that value in place and return the new length.

> The order of elements can be changed. It doesn't matter what you leave beyond the new length.

**Idea** Two pointer is the best solution

***C++ Code***
```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if (nums.empty()) return 0;
        int count = 0;
        for (int i = 0;i < nums.size();++i) {
            if (nums[i] != val) {
                nums[count] = nums[i];
                ++count;
            }
        }
        return count;
    }
};
```

###<a name = "28-implement-strstr"></a>28 Implement strStr()

> Implement strStr().

> Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

**Idea** We don't need to implement kmp algorithm usually. We can figure out the for loop by drawing "northwestern" -> "west"
Two for loop will be useful.

***C++***
```C++
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.length() == 0) return 0;
        if (haystack.length() < needle.length()) return -1;
        for (int i = 0;i < haystack.length() - needle.length() + 1;i++) {
            for (int j = 0;j < needle.length();j++) {
                if (haystack[i+j] != needle[j]) break;
                if (j == needle.length()-1) return i;
            }
        }
        return -1;
    }
};
```

###<a name="29-divide-two-integers"></a>29 Divide Two Integers

> Divide two integers without using multiplication, division and mod operator.

> If it is overflow, return MAX_INT.

**Idea** 

- For example, if we want to find 64 / 2; we can multiple 2 with 2 until it exceed 64, then we can get the answer 32 by loop five times.

- If we want to find 127 / 2, we can follow the step 1 and then use minus, 63 - 2 - 2 - ... 2 < 0, we can get 31 by loop 31 times.

- When the dividend becomes larger, the complexity will exceed as O(n), so we need to use O(log N) again, we use two while loop to accomplish these result.

***C++***
```C++
class Solution {
public:
    int divide(int dividend, int divisor) {
        if (!divisor || (dividend == INT_MIN && divisor == -1))
            return INT_MAX;
        int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;
        long long dvd = labs(dividend);
        long long dvs = labs(divisor);
        int res = 0;
        while (dvd >= dvs) { 
            long long temp = dvs, multiple = 1;
            while (dvd >= (temp << 1)) {
                temp <<= 1;
                multiple <<= 1;
            }
            dvd -= temp;
            res += multiple;
        }
        return sign == 1 ? res : -res; 
    }
};
```

###<a name = "31-next-permutation"></a>31 Next Permutation

> Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

> If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

> The replacement must be in-place, do not allocate extra memory.

> Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

<pre>
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</pre>

**Idea**  

- For example  4,8,7,6,3 => 6,3,4,7,8: 因为后四位数已成最大，只能把第一位数与之后的一位比4稍大的数交换，再将后缀正序。
- 1.从后往前，找到第一个 A[i-1] < A[i]的。也就是第一个排列中的  6那个位置，可以看到A[i]到A[n-1]这些都是单调递减序列。
- 2.从 A[n-1]到A[i]中找到一个比A[i-1]大的值（也就是说在A[n-1]到A[i]的值中找到比A[i-1]大的集合中的最小的一个值）
- 3.交换 这两个值，并且把A[n-1]到A[i]排序，从小到大。

***C++ Code***

```C++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        if (nums.size() <= 1) return;
        int left = (int)nums.size()-2;
        while (left >= 0 && nums[left] >= nums[left+1]) --left;
        if (left<0) {sort(nums.begin(),nums.end());return;}
        int right = (int)nums.size()-1;
        while (right > left && nums[right] <= nums[left]) right--;
        swap(nums[left],nums[right]);
        sort(nums.begin() + left+1,nums.end());
    }
};
```

###<a name="32-longest-valid-parentheses"></a>32 Longest Valid Parentheses
> Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

> For "(()", the longest valid parentheses substring is "()", which has length = 2.

> Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.

**Idea**
for循环,stack存储 '(' or ')' 的index

遇见'('直接push

遇见')'达成匹配时 计算result

若不打成匹配，push')'的下标，以便计算result

四种情况:

1. char == '(' 

直接push

2. char == ')' && stack.top() == '('

达成匹配，s.pop() then 判断stack是否为空

2.1 若为空 result ＝ max(result, i+1)

2.2 若不为空 result = max(result,i-s.top())

3. char == ')' but stack.empty() or stack.top() == ')'

s.push(i)

***C++ Code***
```C++
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> stk;
        int result = 0;
        for (int i = 0;i < s.length();i++) {
            if (s[i] == '(') stk.push(i);
            else {
                if (!stk.empty() && s[stk.top()] == '(') {
                    stk.pop();
                    result = max(stk.empty() ? i+1:i-stk.top(), result);
                }
                else stk.push(i);
            }
        }
        return result;
    }
};
```

###<a name="33-search-in-rotated-sorted-array">33 Search in Rotated Sorted Array

> Suppose a sorted array is rotated at some pivot unknown to you beforehand.

> (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

> You are given a target value to search. If found in the array return its index, otherwise return -1.

> You may assume no duplicate exists in the array.

**Idea**注意判断条件，一定要完全满足

***C++ Code***
```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int low = 0, high = (int)nums.size() - 1;
        while (low + 1< high) {
            int mid = low + (high - low)/2;
            if (nums[mid] == target) return mid;
            if (nums[low] <= nums[mid]) { // 左边有序
                if (target >= nums[low] && target <= nums[mid]) high = mid;
                else low = mid;
            }
            else {
                if (target <= nums[high] && target >= nums[mid]) low = mid;
                else high = mid;
            }
        }
        if (nums[low] == target) return low;
        else if (nums[high] == target) return high;
        else return -1;
    }
};
```

###<a name="34-Search-for-a-range">34 Search for a Range

> Given a sorted array of integers, find the starting and ending position of a given target value.

> Your algorithm's runtime complexity must be in the order of O(log n).

> If the target is not found in the array, return [-1, -1].

<pre>
For example,
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].
</pre>

**Idea** Use binary search twice, one left one right.

***C++ Code***
```C++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = binarySearchLeft(nums, target);
        int right = binarySearchRight(nums, target);
        vector<int> result = {left,right};
        return result;
    }
    
    int binarySearchLeft(vector<int>& nums,int target) {
        int low = 0, high = (int)nums.size() - 1;
        while (low + 1 < high) {
            int mid = low + ((high - low)>>1);
            //if (target == nums[mid]) return mid;
            if (target > nums[mid]) low = mid;
            else high = mid;
        }
        if (nums[low] == target) return low;
        if (nums[high] == target) return high;
        return -1;
    }

    int binarySearchRight(vector<int>& nums,int target) {
        int low = 0, high = (int)nums.size() - 1;
        while (low + 1 < high) {
            int mid = low + ((high - low)>>1);
            //if (target == nums[mid]) return mid;
            if (target < nums[mid]) high = mid;
            else low = mid;
        }
        if (nums[high] == target) return high;
        if (nums[low] == target) return low;
        return -1;
    }
};
```

###<a name="35-search-insert-position"></a>35 Search Insert Position

> Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be > if it were inserted in order.

<pre>
Here are few examples.
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
</pre>

> You may assume no duplicates in the array.

***C++ Code***
```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int low = 0, high = (int)nums.size()-1;
        while (low + 1 < high) {
            int mid = low + (high - low)/2;
            if (nums[mid] == target) return mid;
            else if (target < nums[mid]) high = mid;
            else low = mid;
        }
        if (nums[low]>=target) return low;
        else if (nums[high]>=target) return high;
        else return high+1;
    }
};
```

###<a name="36-valid-sudoku"></a>36 Valid Sudoku

> Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.

> The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

> ***Note:***
> A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.

**Idea** I seperate the board into nine sections, and use mask to test if okay for sudoku.

***C++***
```C++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        vector<int> rows(9,0);
        vector<int> cols(9,0);
        for (int i = 0;i < 3;i++) {
            for (int j = 0;j < 3;j++){
                int mask = 0;
                for (int u = 0;u < 3;u++){
                    for (int v = 0;v < 3;v++){
                        int row = 3*i + u;
                        int col = 3*j + v;
                        if (board[row][col] == '.') continue;
                        int num = board[row][col] - '0';
                        if (mask & (1<<num) || rows[row] & (1<<num) || cols[col] & (1<<num)) return false;
                        mask = mask | (1<<num);
                        rows[row] = rows[row] | (1<<num);
                        cols[col] = cols[col] | (1<<num);
                    }
                }
            }
        }
        return true;
    }
};
```

###<a name="37-sudoku-solver"></a>37 Sudoku Solver

> Write a program to solve a Sudoku puzzle by filling the empty cells.

> Empty cells are indicated by the character '.'.

> You may assume that there will be only one unique solution.

**Idea** Use isvalid every time, and back tracking. Keep in mind we need bool helper function to do recursion.

***C++ Code***

```C++
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board){
        solveSudokuHelper(board);
    }
    bool solveSudokuHelper(vector<vector<char>>& board) {
        for (int i = 0;i < board.size();i++) {
            for (int j = 0;j < board[0].size();j++) {
                if (board[i][j] == '.') {
                    for (int k = 0;k < 9;k++) {
                        board[i][j] = k + '1';
                        if (isValidSudoku(board) && solveSudokuHelper(board)) return true;
                        board[i][j] = '.';
                    }
                    return false;
                }
            }
        }
        return true;
    }
    
    bool isValidSudoku(vector<vector<char>>& board) {
        vector<int> rows(9,0);
        vector<int> cols(9,0);
        for (int i = 0;i < 3;i++) {
            for (int j = 0;j < 3;j++){
                int mask = 0;
                for (int u = 0;u < 3;u++){
                    for (int v = 0;v < 3;v++){
                        int row = 3*i + u;
                        int col = 3*j + v;
                        if (board[row][col] == '.') continue;
                        int num = board[row][col] - '0';
                        if (mask & (1<<num) || rows[row] & (1<<num) || cols[col] & (1<<num)) return false;
                        mask = mask | (1<<num);
                        rows[row] = rows[row] | (1<<num);
                        cols[col] = cols[col] | (1<<num);
                    }
                }
            }
        }
        return true;
    } 
};
```

###<a name="38-count-and-say"></a>38 Count and Say
> The count-and-say sequence is the sequence of integers beginning as follows:

> 1, 11, 21, 1211, 111221, ...

> 1 is read off as "one 1" or 11.

> 11 is read off as "two 1s" or 21.

> 21 is read off as "one 2, then one 1" or 1211.

> Given an integer n, generate the nth sequence.

> Note: The sequence of integers will be represented as a string.

**Idea**  注意 单独的最后处理

***C++ Code***
```C++
class Solution {  
public:  
    string countAndSay(int n) {
    string str = "1";
    for (int i = 1;i < n;i++) {
        int count = 0;
        char ch = '0';
        string str2 = "";
        for (int j = 0;j < str.length();j++) {
            if (str[j]==ch) count++;
            else {
                if (count > 0) {
                    str2 = str2 + char(count+'0') + ch;
                }
                count = 1;
                ch = str[j];
            }
        }
        str2 = str2 + char(count + '0') + ch;
        str = str2;
    }
    return str;
} 
};  
```

###<a name="39-combination-sum"></a>39 Combination Sum
> Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

> The same repeated number may be chosen from C unlimited number of times.

> ***Note:***
<pre>
All numbers (including target) will be positive integers.
Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
The solution set must not contain duplicate combinations.
For example, given candidate set 2,3,6,7 and target 7, 
A solution set is: 
[7] 
[2, 2, 3]
</pre>

***C++ Code***
```C++
class Solution {
public:
    void combinationsHelper(vector<vector<int>> &result,vector<int> &line,vector<int>& candidates, int newtarget,int start) {
        if (newtarget == 0) {
            result.push_back(line);
            return;
        }
        for (int i = start;i < candidates.size();i++) {
            if (newtarget>=0) {
                line.push_back(candidates[i]);
                combinationsHelper(result,line,candidates,newtarget - candidates[i],i);
                line.pop_back();
            }
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> result;
        vector<int> line;
        vector<int> visited(candidates.size(),0);
        sort(candidates.begin(),candidates.end());
        combinationsHelper(result,line,candidates,target,0);
        return result;
    }
};
```

###<a name="40-combination-sum-ii"></a>40 Combination Sum II

> Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

> Each number in C may only be used once in the combination.

> ***Note:***

<pre>
All numbers (including target) will be positive integers.
Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).
The solution set must not contain duplicate combinations.
For example, given candidate set 10,1,2,7,6,1,5 and target 8, 
A solution set is: 
[1, 7] 
[1, 2, 5] 
[2, 6] 
[1, 1, 6] 
</pre>

**Idea** Same solution like permutation and permutation ii.

```C++
class Solution {
public:
    void combinationsHelper(vector<vector<int>> &result,vector<int> &line,vector<int>& candidates,vector<int> &visited, int newtarget,int start) {
        if (newtarget == 0) {
            result.push_back(line);
            return;
        }
        for (int i = start;i < candidates.size();i++) {
            if (i>0 && candidates[i]==candidates[i-1] && visited[i-1]==0) continue;
            if (newtarget>=0) {
                line.push_back(candidates[i]);
                visited[i] = 1;
                combinationsHelper(result,line,candidates,visited,newtarget - candidates[i],i+1);
                line.pop_back();
                visited[i] = 0;
            }
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> result;
        vector<int> line;
        vector<int> visited(candidates.size(),0);
        sort(candidates.begin(),candidates.end());
        combinationsHelper(result,line,candidates,visited,target,0);
        return result;
    }
};
```

###<a name="41-first-missing-number">

> Given an unsorted integer array, find the first missing positive integer.

> For example,

> Given [1,2,0] return 3,

> and [3,4,-1,1] return 2.

> Your algorithm should run in O(n) time and uses constant space.

**Idea** Swap these numbers to make it to their own position.

***C++ Code***
```C++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        for (int i = 0;i < nums.size();) {
            if (nums[i]!=i+1 && nums[i]>0 && nums[i]<=nums.size() && nums[i]!=nums[nums[i]-1]) {
                swap(nums[i],nums[nums[i]-1]);
            }
            else i++;
        }
        for (int i = 0;i < nums.size();i++) {
            if (nums[i] != i+1) return i+1;
        }
        return nums.size() + 1;
    }
};
```
###<a name = "42-trapping-rain-water"></a>42 Trapping Rain Water
> Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

> For example, 

> Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.

**Idea**
- First loop, find the peak index;
- Second and Third loop, sum the result by the difference of temp peak and current height.

***C++ Code***
```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int result = 0;
        int peak = 0;
        int which = 0;
        for (int i = 0;i < height.size();i++) {
            if (peak < height[i]) {
                peak = height[i];
                which = i;
            }
        }
        int leftMax = 0;
        for (int i = 0; i < which;i++) {
            if (height[i] >= leftMax) leftMax = height[i];
            else result += leftMax - height[i];
        }
        int rightMax = 0;
        for (int i = height.size() - 1;i > which;i--) {
            if (height[i] >= rightMax) rightMax = height[i];
            else result += rightMax - height[i];
        }
        return result;
    }
};
```
###<a name = "43-multiply-strings"></a>43 Multiply Strings
> Given two numbers represented as strings, return multiplication of the numbers as a string.

> ***Note:*** The numbers can be arbitrarily large and are non-negative.

***C++ Code***
```C++
class Solution {
public:
    string multiply(string num1, string num2) {
        if (num1 == "0" || num2 == "0") return "0";
        string s = "";
        vector<int> result(num1.size()+num2.size(),0);
        string number1(num1.rbegin(),num1.rend());
        string number2(num2.rbegin(),num2.rend());
        for (int i = 0;i < number1.length();i++) {
            int a = number1[i] - '0';
            for (int j = 0;j < number2.length();j++) {
                int b = number2[j] - '0';
                int c = result[i+j];
                result[i+j] = (c+a*b)%10;
                result[i+j+1] += (c+a*b)/10;
            }
        }
        if(result[num1.size()+num2.size()-1]>0) {
            s += result[num1.size()+num2.size()-1] + '0';
        }
        for (int i = int(num1.length()+num2.length())-2;i >= 0;i--){
            s += result[i]+'0';
        }
        return s;
    }
};
```

###<a name="45-jump-game"></a>45 Jump Game
> Given an array of non-negative integers, you are initially positioned at the first index of the array.

> Each element in the array represents your maximum jump length at that position.

> Your goal is to reach the last index in the minimum number of jumps.

> For example:

> Given array A = [2,3,1,1,4]

> The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

**Idea** We use "last" to keep track of the maximum distance that has been reached by using the minimum steps "ret", whereas "curr" is the maximum distance that can be reached by using "ret+1" steps. Thus, 


***C++ Code***
```C++
class Solution {
public:
    int jump(vector<int>& nums) {
        int ret = 0;      //当前跳数
        int last = 0;     //上一跳可达最远距离
        int curr = 0;     // 当前一跳可达最远距
        for (int i = 0;i < nums.size();i++) {
            //无法向前继跳直接返回 
            if (i > curr) return -1;
            //需要进行下次跳跃，则更新last和当执行的跳数ret  
            if (i > last) {
                last = curr;
                ret++;
            }
            //记录当前可达的最远点 
            curr = max(curr,i+nums[i]);
        }
        return ret;
    }
};
```

###<a name="46-permutations"></a>46 Permutations
> Given a collection of numbers, return all possible permutations.

> For example,

> [1,2,3] have the following permutations:

> [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].

**Idea** Using swap in permutations, and using push_back in combinations. 
         Difference, in the for loop, (int i = start) (permutations) while (int i = 0) (combinations)


***C++ Code using swap***
```C++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> result;
        permuteHelper(result,nums,0);
        return result;
    }
    void permuteHelper(vector<vector<int>> &result, vector<int>& nums,int start) {
        if (start == nums.size()) {
            result.push_back(nums);
            return;
        }
        for (int i = start;i < nums.size();i++) {
            swap(nums[i],nums[start]);
            permuteHelper(result,nums,start + 1);
            swap(nums[i],nums[start]);
        }
    }
};
```

***C++ Code without using swap***
```C++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> line;
        vector<int> visited(nums.size(),0);
        permuteHelper(result,nums,line,visited,0);
        return result;
    }
    
    void permuteHelper(vector<vector<int>> &result, vector<int>& nums,vector<int> &line,vector<int> &visited, int start) {
        if (start == nums.size()) {
            result.push_back(line);
            return;
        }
        for (int i = 0;i < nums.size();i++) {
            if (visited[i]!=0) continue;  // 防止出现 (1,1,1) (2,2,2) (3,3,3)
            line.push_back(nums[i]);
            visited[i] = 1;
            permuteHelper(result,nums,line,visited,start+1);
            line.pop_back();
            visited[i] = 0;
        }
    }
};
```

###<a name = "47-permutations-ii"></a>47 Permutations II

> Given a collection of numbers that might contain duplicates, return all possible unique permutations.

> For example,
> [1,1,2] have the following unique permutations:
> [1,1,2], [1,2,1], and [2,1,1].

**Idea** 
- 跟 Permutations的解法一样，就是要考虑“去重”。先对数组进行排序，这样在DFS的时候，可以先判断前面的一个数是否和自己相等，相等的时候则前面的数必须使用了，自己才能使用，这样就不会产生重复的排列了。

***C++ Code without using swap***
```C++
class Solution {
public:
    vector<vector<int> > permuteUnique(vector<int> &num)
    {
        vector<vector<int>> result;
        vector<int> line;
        vector<int> visited(num.size(),0);
        sort(num.begin(),num.end());
        permutation(num,0,visited,result,line);
        return result;
    }
    void permutation(vector<int> &num,int start,vector<int> &visited,vector<vector<int>> &result,vector<int> &line)
    {
        
        if (start==num.size())
        {
            result.push_back(line);
            return;
        }
        for (int i=0;i<num.size();i++)
        {
            if (visited[i]==0){  // 防止出现 (1,1,1) (2,2,2) (3,3,3)
                if(i>0 && num[i] == num[i-1] && visited[i-1] ==0) continue;  //防止得到相同结果，必须之前使用过 才能使用
                visited[i]=1;
                line.push_back(num[i]);
                permutation(num,start+1,visited,result,line);
                line.pop_back();
                visited[i]=0;
            }
            
        }
    }
};
```

###<a name="48-rotate-image"></a>48 Rotate Image
> You are given an n x n 2D matrix representing an image.

> Rotate the image by 90 degrees (clockwise).

> Follow up:

> Could you do this in-place?

**Idea** swap twice

***C++ Code***
```C++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        if (matrix.size() <= 1 || matrix[0].size() <= 1) return;
        int n = matrix.size();
        for (int i = 0;i < n/2;i++) {
            for (int j = 0;j < n;j++) {
                swap(matrix[i][j],matrix[n-i-1][j]);
            }
        }
        for (int i = 0;i < n;i++) {
            for (int j = i+1;j < n;j++) {
                swap(matrix[i][j],matrix[j][i]);
            }
        }
    }
};
```

###<a name="49-group-anagrams"></a>49 Group Anagrams
> Given an array of strings, group anagrams together.

> For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"], 

> Return:

<pre>
[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
]
</pre>

Note:

For the return value, each inner list's elements must follow the lexicographic order.

All inputs will be in lower-case.

**Idea** Using a hashmap to store the vector's index;

***C++ Code***
```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> result;
        unordered_map<string,int> mp;
        for (auto s:strs) {
            string temp = s;
            sort(temp.begin(),temp.end());
            auto it = mp.find(temp);
            if (it == mp.end()) {
                mp[temp] = result.size();
                result.push_back(vector<string>({s}));
            }
            else {
                result[it->second].push_back(s);
                sort(result[it->second].begin(),result[it->second].end());
            }
        }
        return result;
    }
 };
```

###<a name = "50-pow"></a>50 Pow(x,n)
> Implement pow(x, n).

**Idea** x^2n = (x^2)^n

***C++ Code***
```C++
class Solution {
public:
    double myPow(double x, int n) {
        if (n < 0) {
            x = 1/x;
            n = -n;
        };
        double result = 1;
        while (n) {
            if (n % 2 == 1) {
                result = result * x;
                n--;
            }
            else {
                x = x*x;
                n = n/2;
            }
        }
        return result;
    }
};
```

###<a name="53-maximum-subarray"></a>53 Maximum Subarray
> Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

> For example, given the array [−2,1,−3,4,−1,2,1,−5,4],

> the contiguous subarray [4,−1,2,1] has the largest sum = 6.

***C++ Code***
```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int temp = 0, result = nums[0];
        for (int i = 0;i < nums.size();i++) {
            temp = max(temp+nums[i],nums[i]);
            result = max(result,temp);
        }
        return result;
    }
};
```
###<a name="54-spiral-matrix"></a>53 Spiral Matrix
> Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

> For example,

> Given the following matrix:

<pre>
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
</pre>

***C++ Code***
```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int> > &matrix) {
        vector<int> ans;
        if (matrix.size()==0) return ans;
        int left=0;
        int up=0;
        int right=matrix[0].size()-1;
        int down=matrix.size()-1;
        
        while (left<=right&&up<=down)
        {
            for (int i=left;i<=right;i++)
             {
                 ans.push_back(matrix[up][i]);
             }
             up++;
             for (int i=up;i<=down;i++)
             {
                 ans.push_back(matrix[i][right]);
             }
             right--;
             if (up>down||left>right) return ans;
             for (int i=right;i>=left;i--)
             {
                 ans.push_back(matrix[down][i]);
             }
             down--;
             for (int i=down;i>=up;i--)
             {
                 ans.push_back(matrix[i][left]);
             }
             left++;
             
        }
        return ans;
        
    }
};
```
###<a name = "55-jump-game"></a>55 Jump Game
> Given an array of non-negative integers, you are initially positioned at the first index of the array.

> Each element in the array represents your maximum jump length at that position.

> Determine if you are able to reach the last index.

> For example:

> A = [2,3,1,1,4], return true.

> A = [3,2,1,0,4], return false.

**Idea** Keep a remainder to record how many step it can go as far as possible.

***C++***
```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() <= 1) return true;
        int rmd = nums[0];
        for (int i = 0;i < nums.size();i++) {
            if (--rmd < 0) return false;
            rmd = max(rmd,nums[i]);
        }
        return true;
    }
};
```

###<a name="58-length-of-last-word"></a>58 Length of Last Word
> Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

> If the last word does not exist, return 0.

> Note: A word is defined as a character sequence consists of non-space characters only.

> For example, 

> Given s = "Hello World",

> return 5.

*** C++ Code***
```C++
class Solution {
public:
    int lengthOfLastWord(string s) {
        int count = 0;
        int i = s.length()-1;
        while (s[i] == ' ') i--;
        if (i < 0) return count;
        for (int j = i;j >= 0;j--) {
            if (s[j] == ' ') return count;
            count++;
        }
        return count;
    }
};
```

###<a name="59-spiral-matrix-ii"></a>59 Spiral Matrix II
> Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

> For example,

> Given n = 3,

<pre>
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</pre>
You should return the following matrix:

***C++ Code***
```C++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int up = 0, left = 0;
        int down = n - 1, right = n - 1;
        int elem = 1;
        vector<vector<int>> ret(n,vector<int>(n,0));
        while (up <= down && left <= right) {
            for (int i = left;i <= right;i++) {
                ret[up][i] = elem;
                elem++;
            }
            up++;
            for (int i = up;i <= down;i++) {
                ret[i][right] = elem;
                elem++;
            }
            right--;
            for (int i = right; i >= left;i--) {
                ret[down][i] = elem;
                elem++;
            }
            down--;
            for (int i = down;i >= up;i--) {
                ret[i][left] = elem;
                elem++;
            }
            left++;
        }
        return ret;
    }
};
```

###<a name="60-permutation-sequence"></a>60 Permutation Sequence

> The set [1,2,3,…,n] contains a total of n! unique permutations.

> By listing and labeling all of the permutations in order,

> We get the following sequence (ie, for n = 3):

<pre>
"123"
"132"
"213"
"231"
"312"
"321"
</pre>

> Given n and k, return the kth permutation sequence.

> ***Note:*** Given n will be between 1 and 9 inclusive.

**Idea** One naive implementation through list all permutations in order and find the kth permutation.
Another quicker solution used factorial number, if you write the 4! from 1234 -> 4321 we can find the relation between k and kth sequence.

<pre>
1234
1243
1324
1342
1423
1432
2134
2143
2314  <= k = 9
2341
2413
2431
3124
3142
3214
3241
3412
3421
4123
4132
4213
4231
4312
4321
</pre>

***C++ Code Naive Implementation***
```C++
class Solution {
public:
    void permutationsHelper(vector<vector<int>> &result,vector<int> &line,vector<int> &visited,int n,int start) {
        if (start == n) {
            result.push_back(line);
            return;
        }
        for (int i = 0;i < n;i++) {
            if (visited[i] == 1) continue;
            line.push_back(i+1);
            visited[i] = 1;
            permutationsHelper(result,line,visited,n,start + 1);
            line.pop_back();
            visited[i] = 0;
        }
        return;
    }
    vector<vector<int>> permutations(int n) {
        vector<vector<int>> result;
        vector<int> line;
        vector<int> visited(n,0);
        permutationsHelper(result,line,visited,n,0);
        return result;
    }
    string getPermutation(int n, int k) {
        vector<vector<int>> result = permutations(n);
        vector<int> final = result[k-1];
        string output = "";
        for (auto s:final) {
            output += s + '0';
        }
        return output;
    }
};
```

***C++ Code using factorial number***
```C++
class Solution {
public:
    string getPermutation(int n, int k) {
        k--;
        string result;
        vector<int> factorial = {1, 1, 2, 6, 24, 120, 720, 5040, 40320};
        vector<char> nums;
        for (int i = 0;i < n;i++) {
            nums.push_back(i + '1');
        }
        for (int i = n;i > 0 ;i--) {
            int which = k/factorial[i-1];
            k=k%factorial[i-1];
            result += nums[which];
            nums.erase(nums.begin()+which);
        }
        return result;
    }
};
```

###<a name="61-rotate-list"></a>61 Rotate List
> Given a list, rotate the list to the right by k places, where k is non-negative.

> For example:

> Given 1->2->3->4->5->NULL and k = 2,

> return 4->5->1->2->3->NULL.

***C++ Code***
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (!head || !head->next || k == 0) return head;
        int count = 0;
        ListNode* test = head;
        while (test) {
            count++;
            test = test->next;
        }
        ListNode *fast = head;
        ListNode *slow = head;
        k = k%count;
        if (!k) return head;
        while (k--!=0) {
            fast = fast->next;
        }
        while (fast->next) {
            slow = slow->next;
            fast = fast->next;
        }
        ListNode* newhead = slow->next;
        fast->next = head;
        slow->next = NULL;
        return newhead;
    }
};
```
###<a name="62-unique-paths"></a>62 Unique Paths
> A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

> The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of 

> the grid (marked 'Finish' in the diagram below).

> How many possible unique paths are there?

***C++ Code***
```C++ 
class Solution {
public:
    int uniquePaths(int m, int n) {
        int a[m][n] = {0};
        for (int i = 0;i < n;i++) a[0][i] = 1;
        for (int i = 0;i < m;i++) a[i][0] = 1;
        for (int i = 1;i < m;i++) {
            for (int j = 1;j < n;j++) {
                a[i][j] = a[i-1][j] + a[i][j-1];
            }
        }
        return a[m-1][n-1];
    }
};
```

###<a name="63-unique-paths-ii"></a>63 Unique Paths II
> Follow up for "Unique Paths":

> Now consider if some obstacles are added to the grids. How many unique paths would there be?

> An obstacle and empty space is marked as 1 and 0 respectively in the grid.

> For example,

> There is one obstacle in the middle of a 3x3 grid as illustrated below.

<pre>
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
</pre>

***C++ Code***
```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if (obstacleGrid.size() < 1 || obstacleGrid[0].size() < 1) return 0;
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;

        vector<vector<int>> a(m,vector<int>(n,0));
        a[0][0] = 1;
        for (int i = 1;i < n;i++) {
            if (obstacleGrid[0][i] != 1) a[0][i] = a[0][i-1];
        }
        for (int i = 1;i < m;i++) {
            if (obstacleGrid[i][0] != 1) a[i][0] = a[i-1][0];
        }
        for (int i = 1;i < m;i++) {
            for (int j = 1;j < n;j++) {
                if (obstacleGrid[i][j] != 1) a[i][j] = a[i-1][j] + a[i][j-1];
            }
        }
        return a[m-1][n-1];
    }
};
```

###<a name = "64-minumum-path-sum"></a>64 Minimum Path Sum
> Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

> Note: You can only move either down or right at any point in time.

***C++ Code***
```C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        if (m < 1 || n < 1) return 0;
        for (int i = 1;i < n;i++) {
            grid[0][i] += grid[0][i-1];
        }
        for (int i = 1;i < m;i++) {
            grid[i][0] += grid[i-1][0];
        }
        for (int i = 1;i < m;i++) {
            for (int j = 1;j < n;j++) {
                grid[i][j] += min(grid[i-1][j],grid[i][j-1]);
            }
        }
        return grid[m-1][n-1];
    }
};
```

###<a name = "66-plus-one"></a>66 Plus One

> Given a non-negative number represented as an array of digits, plus one to the number.

> The digits are stored such that the most significant digit is at the head of the list.

***C++ Code***
```C++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        for (int i = digits.size()-1;i >= 0;i--) {
            if (digits[i] != 9) {digits[i]++;return digits;}
            else {
                digits[i] = 0;
            }
        }
        if (digits[0] == 0) digits.insert(digits.begin(),1);
        return digits;
    }
};
```

###<a name = "67-add-binary"></a>67 Add Binary
> Given two binary strings, return their sum (also a binary string).

> For example,

> a = "11"

> b = "1"

> Return "100".

***C++ Code***
```C++
class Solution {
public:
    string addBinary(string a, string b) {
        int i = a.length()-1, j = b.length()-1;
        string result;
        int carry = 0;
        while (i >= 0 && j >= 0) {
            int elem = a[i] - '0' + b[j] - '0' + carry;
            if (elem == 3) {
                result = "1" + result;
                carry = 1;
            }
            else if(elem == 2) {
                result = "0" + result;
                carry = 1;
            }
            else {
                if (elem == 1) result.insert(result.begin(),'1');
                else result.insert(result.begin(),'0');
                carry = 0;
            }
            --i;
            --j;
        }
        while (i >= 0) {
            int elem = a[i] - '0' + carry;
            if (elem == 2) {
                result = "0" + result;
                carry = 1;
            }
            else {
                if (elem == 1) result.insert(result.begin(),'1');
                else result.insert(result.begin(),'0');
                carry = 0;
            }
            i--;
        }
        while (j >= 0) {
            int elem = b[j] - '0' + carry;
            if (elem == 2) {
                result = "0" + result;
                carry = 1;
            }
            else {
                if (elem == 1) result.insert(result.begin(),'1');
                else result.insert(result.begin(),'0');
                carry = 0;
            }
            j--;
        }
        if (carry) result = "1" + result;
        return result;
    }
};
```

###<a name="69-sqrt"></a>69 Sqrt(x)
> Implement int sqrt(int x).

> Compute and return the square root of x.

**Idea** Using binary search to find it, and be care of sqrt(10) is 3, so if 3*3 < 10 && 4*4 > 10, can be a criterion to find it.

***C++ Code***
```C++
class Solution {
public:
    int mySqrt(int x) {
        if (x < 0) return -1;
        if (x == 0) return 0;
        int low = 1;
        int high = x/2;
        while (low <= high) {
            int mid = low + (high - low)/2;
            if (mid <= x / mid && (mid+1 >= x/(mid + 1) )) return mid;
            else if (mid < x / mid) low = mid + 1;
            else high = mid - 1;
        }
        return low;
    }
};
```

###<a name="70-climbing-stairs"></a>70 Climbing Stairs
> You are climbing a stair case. It takes n steps to reach to the top.

> Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

***C++ Code***
```C++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp;
        dp.push_back(1);
        dp.push_back(2);
        for (int i = 2;i < n;i++) {
            dp.push_back(dp[i-1]+dp[i-2]);
        }
        return dp[n-1];
    }
};
```

###<a name = "70-simplify-path"></a>70 Simplify Path
> Given an absolute path for a file (Unix-style), simplify it.

> For example,

> path = "/home/", => "/home"

> path = "/a/./b/../../c/", => "/c"

> ***Corner Cases:***

> Did you consider the case where path = "/../"?

> In this case, you should return "/".

> Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".

> In this case, you should ignore redundant slashes and return "/home/foo".

**Idea** At first, we should ignore redundant "/", and then push the useful path like "home" into stack, if it's ".." then pop out, if it's ".", then do nothing;

***C++ Code***
```C++
class Solution {
public:
    string simplifyPath(string path) {
        stack<string> s;
        string result = "";
        for (int i = 0;i < path.length();i++) {
            while (path[i] == '/') i++;
            if (i == path.length()) break;
            string elem = "";
            while (path[i]!='/' && i < path.length()) {elem = elem + path[i];i++;}
            if (elem == "..") {
                if (!s.empty()) s.pop();
            }
            else if (elem != ".") s.push(elem);
        }
        if (s.empty()) result = "/";
        else {
            while (!s.empty()) {
                result = "/" +s.top() + result;
                s.pop();
            }
        }
        return result;
    }
};
```

###<a name = "72-edit-distance"></a>72 Edit Distance
> Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)

> You have the following 3 operations permitted on a word:

> a) Insert a character

> b) Delete a character

> c) Replace a character

**Idea* Here are three dynamic programming problems' solution:

1. Longest Common Subsequence (算法书原题)
1.1 c[i,j] = 0 (if i=0 or j=0)
1.2 c[i,j] = c[i-1,j-1]+1 (if a[i]=b[j])
1.3 c[i,j] = min(c[i-1][j], c[i][j-1]) (if a[i]!=b[j])
Finally return c[a.length()][b.length()];

2. Longest Common Substring
2.1 c[i,j] = 0 (if i=0 or j=0)
2.2 c[i,j] = c[i-1,j-1]+1 (if a[i]=b[j])
2.3 c[i,j] = 0 (if a[i]!=b[j])
Return the max value of all entries;

3. Edit Distance(Minimum Changes to make the same)
3.1 c[i,0] or c[0,i] = i 
3.2 c[i,j] = c[i-1,j-1] (if a[i]=b[j])
3.3 c[i,j] = min(c[i-1][j], c[i][j-1],c[i-1][j-1]) + 1 (if a[i]!=b[j])

***C++ Code***
```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.length()+1,vector<int>(word2.length()+1,0));
        for(int i = 0;i <= word1.length();i++) {
            dp[i][0] = i; 
        }
        for(int i = 0;i <= word2.length();i++) {
            dp[0][i] = i;
        }
        for(int i = 1;i <= word1.length();i++) {
            for (int j = 1;j <= word2.length();j++) {
                if (word1[i-1] == word2[j-1]) {
                    dp[i][j] = dp[i-1][j-1];
                }
                else {
                    dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
};
```

###<a name="73-set-matrix-zeroes"></a>73 Set Matrix Zeroes

> Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.

**Idea** 
1. O(n^2) solution, using a matrix to store if or else this entry should be zero;
2. O(n) solution, using a row and col to store if or else this col or row should be zero;
3. Find one zero entry first, then use his row and col to do O(n) solution, because it's not extra space,so it's O(1).

***C++ Code***
```C++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int row, col;
        int flag = 1;
        for (int i = 0;i < matrix.size();i++) {
            for (int j = 0;j < matrix[0].size();j++) {
                if (matrix[i][j] == 0) 
                {
                    row = i;
                    col = j;
                    flag = 0;
                    break;
                }
            }
        }
        if (flag) return;
        for (int i = 0;i < matrix.size();i++) {
            for (int j = 0;j < matrix[0].size();j++) {
                if (matrix[i][j] == 0) 
                {
                    matrix[row][j] = 0;
                    matrix[i][col] = 0;
                }
            }
        }
        //Clean the row;
        for (int i = 0;i < matrix.size();i++) {
            if (i != row && matrix[i][col] == 0) {
                for (int j = 0;j < matrix[0].size();j++) {
                    matrix[i][j] = 0;
                }
            }
        }
        //Clean the col
        for (int j = 0;j < matrix[0].size();j++) {
            if (j != col && matrix[row][j] == 0) {
                for (int i = 0;i < matrix.size();i++) {
                    matrix[i][j] = 0;
                }
            }
        }
        for (int i = 0;i < matrix.size();i++) {
            matrix[i][col] = 0;
        }
        for (int i = 0;i < matrix[0].size();i++) {
            matrix[row][i] = 0;
        }
        
    }
};
```

###<a name="74-search-a-2d-matrix"></a>74 Search a 2D Matrix
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

* Integers in each row are sorted from left to right.
* 
* The first integer of each row is greater than the last integer of the previous row.
* 
For example,

Consider the following matrix:
<pre>
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</pre>

Given target = 3, return true.
**Idea** Recognize the matrix as a long array

***C++ Code***
```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        if (m*n == 0) return false;
        int low = 0, high = m*n - 1;
        while (low + 1 < high) {
            int mid = low + (high - low)/2;
            if (matrix[mid/n][mid%n] == target) return true;
            else if (matrix[mid/n][mid%n] > target) high = mid-1;
            else low = mid+1;
        }
        if (matrix[low/n][low%n] == target || matrix[high/n][high%n] == target) return true;
        return false;
    }
};
```

###<a name="75-sort-colors"></a>75 Sort Colors

> Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the 
> colors in the order red, white and blue.

> Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

> ***Note:***

> You are not suppose to use the library's sort function for this problem.

***C++ Code***
```C++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int red = 0;
        int white = 0;
        for (int i = 0;i < nums.size();i++) {
            if (nums[i] == 0) red++;
            else if (nums[i] == 1) white++;
        }
        for (int i = 0;i < red;i++) {
            nums[i] = 0;
        }
        for (int i = red;i < red+white;i++) {
            nums[i] = 1;
        }
        for (int i = red+white;i < nums.size();i++) {
            nums[i] = 2;
        }
        return;
    }
};
```

###<a name="76-minimum-size-subarray-sum"></a>76 Minimum Size Subarray Sum
> Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. 

> If there isn't one, return 0 instead.

> For example, given the array [2,3,1,2,4,3] and s = 7,

> the subarray [4,3] has the minimal length under the problem constraint.

**Idea** Sliding window, if bigger, then move start to right, if less, move end to right

***C++ Code***
```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int ret = INT32_MAX;
        int temp = 0;
        int start = 0, end = 0;
        if (nums.size() < 1) return 0;
        while (start <= end && end < nums.size()) {
            while (temp < s && end < nums.size()) {
                temp += nums[end];
                end++;
            }
            while (temp >= s && start <= end) {
                temp = temp-nums[start];
                ret = min(ret,end-start);
                start++;
            }
        }
        return ret == INT32_MAX? 0:ret;
    }
};
```
###<a name="77-combinations"></a>77 Combinations

> Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

> For example,

> If n = 4 and k = 2, a solution is:

> The total number of unique paths is 2.

> ***Note:*** m and n will be at most 100.

<pre>
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre>

**Idea** In here we don't need the visited matrix, because we move forward next loop using (i+1) instead of (start+1), so it won't get 1,1,1,1 because we moved forward.

***C++ Code***
```C++
class Solution {
public:
    void combinationsHelper(vector<vector<int>> &result,vector<int> &line,int n, int k, int start) {
        if (line.size() == k) {
            result.push_back(line);
            return;
        }
        for (int i = start;i < n;i++) {
            line.push_back(i+1);
            combinationsHelper(result,line,n,k,i+1);
            line.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> result;
        vector<int> line;
        combinationsHelper(result,line,n,k,0);
        return result;
    }
};
```

###<a name="78-subsets"></a>78 Subsets
> Given a set of distinct integers, nums, return all possible subsets.

> Note:

> Elements in a subset must be in non-descending order.

> The solution set must not contain duplicate subsets.

> For example,

> If nums = [1,2,3], a solution is:

<pre>
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</pre>

***C++ Code***
```C++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> line;
        sort(nums.begin(),nums.end());
        subsetsHelper(result,line,nums,0);
        return result;
    }
    void subsetsHelper(vector<vector<int>> &result,vector<int> &line,vector<int> nums, int start) {
        result.push_back(line);
        for (int i = start;i < nums.size();i++) {
            line.push_back(nums[i]);
            subsetsHelper(result,line,nums,i+1);
            line.pop_back();
        }
    }
};
```



###<a name="80-remove-duplicates-from-sorted-list-ii"></a>
> Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

> For example,

> Given 1->2->3->3->4->4->5, return 1->2->5.

> Given 1->1->1->2->3, return 2->3.

***C++ Code***
```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode dummyNode(0);
        dummyNode.next = head;
        ListNode *prev = &dummyNode;
        int flag = 0;
        while(head) {
            while (head && head->next && head->val == head->next->val) {
                head->next = head->next->next;
                flag = 1;
            }
            if (flag == 1) {
                prev->next = prev->next->next;
                head = prev->next;
                flag = 0;
            }
            else {
                prev = prev->next;
                head = head->next; 
            }
        }
        return dummyNode.next;
        
    }
};
```
###<a name = "81-search-in-rotated-array-ii"></a>81 Search in Rotated Array II
> Follow up for "Search in Rotated Sorted Array":

> What if duplicates are allowed?

> Would this affect the run-time complexity? How and why?

> Write a function to determine if a given target is in the array.

***C++ Code***
```C++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int low = 0, high = (int)nums.size() - 1;
        while (low + 1< high) {
            int mid = low + (high - low)/2;
            if (nums[mid] == target) return true;
            if (nums[low] < nums[mid]) { // 左边有序
                if (target >= nums[low] && target <= nums[mid]) high = mid;
                else low = mid;
            }
            else if (nums[low] > nums[mid]){
                if (target <= nums[high] && target >= nums[mid]) low = mid;
                else high = mid;
            }
            else low++;
        }
        if (nums[low] == target) return true;
        else if (nums[high] == target) return true;
        else return false;
    }
};
```

###<a name = "82-remove-duplicates-from-sorted-array-ii"></a>80 Remove Duplicates from Sorted Array II
> Follow up for "Remove Duplicates":

> What if duplicates are allowed at most twice?

> For example,

> Given sorted array nums = [1,1,1,2,2,3],

> Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what 

> you leave beyond the new length.

**Idea** Two pointers:
有个误区，按照常理我会在循环中写
```C++
if (nums[i] == nums[i-1] && nums[i] == nums[i-2]) continue;
```
然而考虑到遍历[1,1,1,2,2,3]到第二个‘2’时，此时nums已经是[1,1,2,2,2,3]，因此按照上述判断会跳过第二个2导致错误

应该使用如下代码：

***C++ Code***
```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() <= 2) return nums.size();
        int p = 2;
        for (int i = 2;i < nums.size();i++) {
            if (nums[i] == nums[p-1] && nums[i] == nums[p-2]) continue;
            nums[p++] = nums[i];  
        }
        return p;
    }
};
```

###<a name="83-remove-duplicates-from-sorted-list"></a>83 Remove Duplicates from Sorted List
> Given a sorted linked list, delete all duplicates such that each element appear only once.

> For example,

> Given 1->1->2, return 1->2.

> Given 1->1->2->3->3, return 1->2->3.

***C++ Code***
```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == NULL) return head;
        ListNode* cur = head;
        while (cur && cur->next) {
            if (cur->val == cur->next->val) cur->next = cur->next->next;
            else cur = cur->next; 
        }
        return head;
    }
};
```

###<a name="84-largest-rectangle-in-histogram"></a>84 Largest Rectangle in Histogram
> Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

**Idea**
http://www.cnblogs.com/felixfang/p/3676193.html
1. O(n^2) solution: 中心开花思想，比如从其中的某一个中心向两侧扩展，如果比它小停止，否则累加。

2. O(n) solution: 一维DP，根据stack弹入弹出计算。第一步弹入0，以防出现一直上升情况，考虑case:[1,2,3,4,5,1];
每次当height[i]大于栈顶元素便push
若小于，则将stack里的元素一个个弹出，在每次弹出的同时计算curmax。

***C++ Code***
```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& height) {
        height.push_back(0);
        stack<int> s;
        int ret = 0;
        for (int i = 0;i < height.size();i++) {
            if (s.empty() || height[i] > height[s.top()]) s.push(i);
            else {
                int tmp = s.top();
                s.pop();
                if (s.empty()) {
                    ret = max(ret,height[tmp]*i);
                }
                else {
                    ret = max(ret,height[tmp]*(i-1-s.top()));
                }
                i--;
            }
        }
        return ret;
    }
};
```

###<a name="85-maximal-rectangle"></a>85 Maximal Rectangle
> Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.

***C++ Code***
```C++
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if (matrix.size() < 1 || matrix[0].size() < 1) return 0;
        vector<vector<int>> dp(matrix.size(),vector<int>(matrix[0].size(),0)); 
        for (int i = 0;i < matrix.size();i++) {
            for (int j = 0;j < matrix[0].size();j++) {
                dp[i][j] = matrix[i][j] -'0';
                if (dp[i][j] != 0 && i > 0) {
                    dp[i][j] += dp[i-1][j];
                }
            }
        }
        int result = 0;
        for (int i = 0;i < matrix.size();i++) result = max(result,maximalRectangleHelper(dp[i]));
        return result;
    }
    int maximalRectangleHelper(vector<int> &height) {
        height.push_back(0);
        stack<int> s;
        int ret = 0;
        for (int i = 0;i < height.size();i++) {
            if (s.empty() || height[i] > height[s.top()]) s.push(i);
            else {
                int tmp = s.top();
                s.pop();
                if (s.empty()) ret = max(ret,height[tmp]*i);
                else ret = max(ret,height[tmp]*(i-1-s.top()));
                i--;
            }
        }
        return ret;
    }
};
```

###<a name="86-partition-list"></a>86 Partition List
> Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

> You should preserve the original relative order of the nodes in each of the two partitions.

> For example,

> Given 1->4->3->2->5->2 and x = 3,

> return 1->2->2->4->3->5.

***C++ Code***
```C++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* l = new ListNode(0);
        ListNode* r = new ListNode(0);
        ListNode *dummyl = l;
        ListNode *dummyr = r;
        while (head) {
            if (head->val < x) {
                l->next = head;
                l = l->next;
            }
            else {
                r->next = head;
                r = r->next;
            }
            head = head->next;
        }
        r->next = NULL;
        l->next = dummyr->next;
        return dummyl->next;
    }
};
```

###<89-gray-code></a>89 Gray Code
> The gray code is a binary numeral system where two successive values differ in only one bit.

> Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

> For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:
<pre>
00 - 0
01 - 1
11 - 3
10 - 2
</pre>

> Note:

> For a given n, a gray code sequence is not uniquely defined.

> For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.

> For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.

***C++ Code***
```C++
class Solution {
public:
    vector<int> grayCode(int n) {
        int x = 1<<n;
        vector<int> result;
        for (int i = 0;i < x;i++) {
            result.push_back(i^(i>>1));
        }
        return result;
    }
};
```

###<a name = "88-merge-sorted-array"></a>88 Merge Sorted Array
> Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

> Note:

> You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. 

> The number of elements initialized in nums1 and nums2 are m and n respectively.

***C++ Code***
```C++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        while (i>=0 && j>=0) nums1[i+j+1] = nums1[i]>nums2[j]? nums1[i--]: nums2[j--];
        while(j>=0) nums1[j] = nums2[j--];
    }
};
```

###<89-gray-code></a>89 Gray Code
> The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:

00 - 0
01 - 1
11 - 3
10 - 2
Note:
For a given n, a gray code sequence is not uniquely defined.

For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.

For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.

###<a name= "90-subsets-ii"></a>90 Subsets II
> Given a collection of integers that might contain duplicates, nums, return all possible subsets.

> Note:

> Elements in a subset must be in non-descending order.

> The solution set must not contain duplicate subsets.

> For example,

> If nums = [1,2,2], a solution is:

<pre>
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</pre>

***C++ Code***
```C++
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> line;
        sort(nums.begin(),nums.end());
        subsetsHelper(result,line,nums,0);
        return result;
    }
    void subsetsHelper(vector<vector<int>> &result,vector<int> &line,vector<int> nums, int start) {
        result.push_back(line);
        for (int i = start;i < nums.size();i++) {
            if (i > start && nums[i] == nums[i-1]) continue; 
            line.push_back(nums[i]);
            subsetsHelper(result,line,nums,i+1);
            line.pop_back();
        }
    }
};
```

###<a name="91-decode-ways"></a>91 Decode Ways
> A message containing letters from A-Z is being encoded to numbers using the following mapping:
<pre>
'A' -> 1
'B' -> 2
...
'Z' -> 26
<pre>

> Given an encoded message containing digits, determine the total number of ways to decode it.

> For example,

> Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

> The number of ways decoding "12" is 2.

**Idea**

> 每次对于当前的字符判断是否属于1-9（0肯定不行，因为0不在1-26中，

> 如果属于，那么当前的字符可以被decode，并且和f[n-1]组合，f[n] += f[n-1]

> 然后对于当前字符和前一个字符组成的字符串判断是否属于10-26，

> 如果属于，那么这两个字符可以被decode，并且和f[n-2]组合，f[n] += f[n-2]

> 有点条件斐波那契的意思

***C++ Code***
```C++
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s.length() == 0) return 0;
        vector<int> dp(s.length()+1,0);
        dp[0] = 1;
        for (int i = 0;i < s.length();i++) {
            int cur = s[i] - '0';
            if (cur > 0 && cur <= 9) dp[i+1] += dp[i];
            if (i >= 1) {
                int sum = cur + 10 * (s[i-1] - '0');
                if (sum >= 10 && sum <= 26) {
                    dp[i+1] += dp[i-1];
                }
            }
        }
        return dp[s.length()];
    }
};
```

###<a name = "92-reverse-linked-list"></a>92 Reverse Linked List
> Reverse a linked list from position m to n. Do it in-place and in one-pass.

> For example:

> Given 1->2->3->4->5->NULL, m = 2 and n = 4,

> return 1->4->3->2->5->NULL.

> Note:

> Given m, n satisfy the following condition:

> 1 ≤ m ≤ n ≤ length of list.

***C++ Code***
```C++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if (!head || !head->next||(m==n)) return head;
        ListNode* a = NULL;
        ListNode* b = head;
        ListNode* c = NULL;
        int count = 1;
        if (m == 1) {
            while (count <= n) {
                c = b->next;
                b->next = a;
                a = b;
                b = c;
                count++;
            }
            head->next = b;
            return a;
        }
        else {
            ListNode* dummy = head;
            count = 1;
            while (count < m-1) {
                dummy = dummy->next;
                count++;
            }
            count = 0;
            ListNode *start = dummy->next;
            b = start;
            while (count <= n-m) {
                c = b->next;
                b->next = a;
                a = b;
                b = c;
                count++;
            }
            start->next = b;
            dummy->next = a;
            return head;
        }
    }
};
```

###<a name="93-restore-ip-addresses"></a>93 Restore IP Addresses
> Given a string containing only digits, restore it by returning all possible valid IP address combinations.

> For example:

> Given "25525511135",

> return ["255.255.11.135", "255.255.111.35"]. (Order does not matter)

***C++ Code***
```C++
class Solution {
private:
    void ipHelper(string str,vector<string> &result,string elem, int start, int part)
    {
        if (str.size() - start > (4 - part)*3) return;
        if (str.size() - start < (4 - part)) return;
        if (start == str.size() && part == 4) {
            elem.pop_back();
            result.push_back(elem);
            return;
        }
        int count = 0;
        for (int i = 0;i < 3;i++) {
            count = count*10 + str[start+i]-'0';
            if (count <= 255) {
                elem += str[start+i];
                ipHelper(str, result, elem+'.', start+i+1, part+1);
            }
            if (count == 0) break;
        }
        
        
    }
public:
    vector<string> restoreIpAddresses(string s) {
        vector<string> result;
        string line;
        ipHelper(s, result, line, 0, 0);
        return result;
    }
};
```

###<a name = "94-binary-tree-inorder-travesal"></a>94 Binary Tree Inorder Travesal
> Given a binary tree, return the inorder traversal of its nodes' values.

> For example:

> Given binary tree {1,#,2,3},
<pre>
   1
    \
     2
    /
   3
 </pre>
 
> return [1,3,2].

> ***Note:*** Recursive solution is trivial, could you do it iteratively?

***C++ Recursive Solution***
```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        if (root == NULL) return result;
        dfs(result,root);
        return result;
    }
    void dfs(vector<int> &result, TreeNode* root) {
        if (root == NULL) return;
        dfs(result,root->left);
        result.push_back(root->val);
        dfs(result,root->right);
    }
};
```

***C++ Iterative Solution***
```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode *> s;
        vector<int> result;
        if (root == NULL) return result;
        TreeNode* cur = root;
        while (!s.empty() || cur) {
            if (cur) {
                s.push(cur);
                cur = cur->left;
            }
            else {
                cur = s.top();
                result.push_back(cur->val);
                s.pop();
                cur = cur->right;
            }
        }
        return result;
    }
};
```

###<a name="95-unique-binary-search-trees"></a>95 Unique Binary Search Trees
> Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

> For example,

> Given n = 3, there are a total of 5 unique BST's.

<pre>
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>

***C++ Code***
```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2;i <= n;i++) {
            for (int j = 1;j <= i;j++) {
                dp[i] += dp[j-1] * dp[i-j];
            }
        }
        return dp[n];
    }
};
```

###<a name="96-unique-binary-search-trees"></a>96 Unique Binary Search Trees
> Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.

> For example,

> Given n = 3, your program should return all 5 unique BST's shown below.
<pre>
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>
**Idea** 此题像subset，help函数里三个for loop，一个正常for loop，for loop，另外两个for loop用于遍历left 和 right 数组

***C++ Code***
```C++
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        vector<TreeNode*> result;
        if (n == 0) return result;
        generateHelper(result,1,n);
        return result;
    }
    void generateHelper(vector<TreeNode*> &result, int start, int end) {
        if (start > end) {
            TreeNode *nor = NULL;
            result.push_back(nor);
        }
        for (int i = start;i <= end;i++) {
            vector<TreeNode*> lefts;
            generateHelper(lefts,start,i-1);
            vector<TreeNode*> rights;
            generateHelper(rights,i+1,end);
            for (int li = 0;li < lefts.size();li++) {
                for (int ri = 0;ri < rights.size();ri++) {
                    TreeNode* curr = new TreeNode(i);
                    curr->left = lefts[li];
                    curr->right = rights[ri];
                    result.push_back(curr);
                }
            }
        }
    }
};
```

###<a name="98-validate-binary-search-tree"></a>98 Validate Binary Tree
> Given a binary tree, determine if it is a valid binary search tree (BST).

> Assume a BST is defined as follows:

1. The left subtree of a node contains only nodes with keys less than the node's key.
2. The right subtree of a node contains only nodes with keys greater than the node's key.
3. Both the left and right subtrees must also be binary search trees.

**Idea** Print the inorder travesal and check if it's inorder.

***C++ Code***
```C++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if (root == NULL || (root->left == NULL && root->right == NULL)) return true;
        vector<int> result;
        dfs(result,root);
        for (int i = 0;i < result.size()-1;i++) {
            if (result[i] >= result[i+1]) return false;
        }
        return true;
    }
    void dfs(vector<int> &result, TreeNode* root) {
        if (root == NULL) return;
        dfs(result,root->left);
        result.push_back(root->val);
        dfs(result,root->right);
    }
};
```


###<a name="100-same-tree"></a>100 Same Tree
> Given two binary trees, write a function to check if they are equal or not.

> Two binary trees are considered equal if they are structurally identical and the nodes have the same value.

***C++ Code***
```C++ 
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == NULL && q == NULL) return true;
        if (p != NULL || q != NULL) {
            if (p != NULL && q != NULL) {
                if (p->val == q->val) return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);
            }
            return false;
        }
    }
};
```

###<a name="101-symmetric-tree"></a>101 Symmetric Tree
> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

> For example, this binary tree is symmetric:
<pre>
    1
   / \
  2   2
 / \ / \
3  4 4  3
</pre>

> But the following is not:
<pre>
    1
   / \
  2   2
   \   \
   3    3
</pre>

**Idea** 主意是判断A->left ==  B->right && B->left == A->right

***C++ Code***
```C++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        else return isSym(root->left,root->right);
    }
    bool isSym(TreeNode* A, TreeNode* B) {
        if (!A && !B) return true;
        else if (A && B) return (A->val == B->val) && isSym(A->left, B->right) && isSym(A->right,B->left);
        else return false;
    } 
};
```

###<a name="102-binary-tree-level-order-travesal"></a>102 Binary Tree Level Order Traversal
> Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

**Idea** 小技巧：在push root的同时push NULL，之后每次遇到NULL并且q里不为空时 将整行push并加入新的NULL

***C++ Code***
```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> q;
        vector<vector<int>> result;
        vector<int> line;
        if(!root) return result;
        q.push(root);
        q.push(NULL);
        
        while (!q.empty()) {
            TreeNode* curr = q.front();
            q.pop();
            if (curr == NULL) {
                result.push_back(line);
                line.clear();
                if (!q.empty()) q.push(NULL);
                continue;
            }
            line.push_back(curr->val);
            if (curr->left) q.push(curr->left);
            if (curr->right) q.push(curr->right);
        }
        
        return result;
    }
};
```

###<a name="103-binary-tree-zigzag-level-order-travesal"></a>103 Binary Tree Zigzag Level Order Travesal
> Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

**Idea**

***C++ Code***
```C++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result;
        vector<int> line;
        queue<TreeNode*> q;
        bool flag = true;
        if (!root) return result;
        q.push(root);q.push(NULL);
        while (!q.empty()) {
            TreeNode* curr = q.front();q.pop();
            if (curr == NULL) {
                result.push_back(line);
                line.clear();
                flag = !flag;
                if (!q.empty()) q.push(NULL);
                continue;
            }
            if (flag) line.push_back(curr->val);
            else line.insert(line.begin(),curr->val);
            
            if (curr->left) q.push(curr->left);
            if (curr->right) q.push(curr->right);
        }
        return result;
    }
};
```

###<a name="104-maximum-depth-of-binary-tree"></a>104 Maximum Depth of Binary Tree
> Given a binary tree, find its maximum depth.

> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

***C++ Code***
```C++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        return max(maxDepth(root->left)+1,maxDepth(root->right)+1);
    }
};
```

###<a name="105-construct-binary-tree-from-preorder-and-inorder-traversal"></a>105 Construct Binary Tree from Preorder and Inorder Traversal
> Given preorder and inorder traversal of a tree, construct the binary tree.

**Idea**
若前序为 6 5 4 8 7 9
而中序为 4 5 6 7 8 9
从 6 开始，找到中序6的位置。则6左边的都是左子树，右边都是右子数，依此递归即可
http://blog.csdn.net/benbenab/article/details/8139440


***C++ Code***
```C++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.size() == 0 || inorder.size() == 0 || preorder.size() != inorder.size()) return NULL;
        return buildTreeHelper(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
    }
    TreeNode* buildTreeHelper(vector<int>& preorder, int preStart, int preEnd,vector<int>& inorder, int inStart, int inEnd) {
        if (preStart > preEnd) return NULL;
        TreeNode *curr = new TreeNode(preorder[preStart]);
        if (preStart == preEnd) return curr;
        int i = 0;
        for (i = inStart;i < inEnd;i++) {
            if (inorder[i] == curr->val) break;
        }
        curr->left = buildTreeHelper(preorder,preStart + 1,preStart + i - inStart,inorder,inStart,i-1);
        curr->right = buildTreeHelper(preorder,preStart + i - inStart + 1,preEnd,inorder,i+1,inEnd);
        return curr;
    }
};
````

###<a name="106-construct-binary-tree-from-inorder-and-postorder-traversal"></a>106 Construct Binary Tree from Inorder and Postorder Traversal
> Given inorder and postorder traversal of a tree, construct the binary tree.
**Idea**
中序为 4 5 6 7 8 9
后序为4 5 7 9 8 6 
从 6 开始，找到中序6的位置。则6左边的都是左子树，右边都是右子数，依此递归即可


***C++ Code***
```C++
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (postorder.size() == 0 || inorder.size() == 0 || postorder.size() != inorder.size()) return NULL;
        return buildTreeHelper(inorder,0,inorder.size()-1,postorder,postorder.size()-1,0);
    }
    TreeNode* buildTreeHelper(vector<int>& inorder, int inStart, int inEnd,vector<int>& postorder, int postStart, int postEnd) {
        if (postEnd > postStart) return NULL;
        TreeNode* curr = new TreeNode(postorder[postStart]);
        if (postEnd == postStart) return curr;
        int i = 0;
        for (i = inStart;i < inEnd;i++) {
            if (inorder[i] == curr->val) break;
        }
        curr->right = buildTreeHelper(inorder, i+1, inEnd, postorder, postStart - 1, postStart - 1 - (inEnd - 1 - i));
        curr->left = buildTreeHelper(inorder, inStart, i-1, postorder, postStart - 1 - (inEnd - 1 - i) - 1,postEnd);
        return curr;
    }
};

```


###<a name="107-binary-tree-level-order-travesal-ii"></a>107 Binary Tree Level Order Traversal II
> Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

***C++ Code***
```C++
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        vector<vector<int>> result;
        vector<int> line;
        queue<TreeNode*> q;
        if (root == NULL) return result;
        q.push(root);
        q.push(NULL);
        while(!q.empty()) {
            TreeNode* curr = q.front();
            q.pop();
            if (curr == NULL) {
                result.insert(result.begin(),line);
                line.clear();
                if (!q.empty()) {
                    q.push(NULL);
                }
                continue;
            }
            line.push_back(curr->val);
            if (curr->left) q.push(curr->left);
            if (curr->right) q.push(curr->right);
        }
        return result;
    }
};
```

###<a name="108-convert-sorted-array-to-binary-search-tree"></a>108 Convert Sorted Array to Binary Search Tree
> Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

***C++ Code***
```C++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if (nums.size() == 0) return NULL;
        return sortedHelper(nums,0,nums.size()-1);
    }
    TreeNode* sortedHelper(vector<int>& nums,int start,int end) {
        if (start > end) return NULL;
        int mid = (start + end) / 2;
        TreeNode* curr = new TreeNode(nums[mid]);
        if (start == end) return curr;
        curr->left = sortedHelper(nums,start,mid-1);
        curr->right = sortedHelper(nums,mid+1,end);
        return curr;
    }
};
```

###<a name="109-convert-sorted-list-to-binary-search-tree"></a>109 Convert Sorted List to Binary Search Tree
> Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

***C++ Code***
```C++
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        if (head == NULL) return NULL;
        if (head->next ==NULL) {
            TreeNode* curr = new TreeNode(head->val);
            return curr;
        }
        ListNode* fast = head->next->next;
        ListNode* slow = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* right = slow->next->next;
        TreeNode* curr = new TreeNode(slow->next->val);
        slow->next = NULL;
        curr->left = sortedListToBST(head);
        curr->right = sortedListToBST(right);
        return curr;
    }
};
```

###<a name= "110-balanced-binary-tree"></a>110 Balanced Binary Tree
> Given a binary tree, determine if it is height-balanced.

> For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

***C++ Code O(NLogN)***
```C++
class Solution {
public:
    bool isBalanced(TreeNode *root) 
    {
        if (root==NULL) return true;
        if (abs(maxDepth(root->left)-maxDepth(root->right))<=1)
            return isBalanced(root->left)&&isBalanced(root->right);
        else
            return false;
    }
    
    int maxDepth(TreeNode *root)
    {
        if (root == NULL ) return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```


***C++ Code O(N)***
```C++
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if (maxDepth(root) == -1) return false;
        else return true;
    }
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int leftHeight = maxDepth(root->left);
        if (leftHeight == -1) return -1;
        int rightHeight = maxDepth(root->right);
        if (rightHeight == -1) return -1;
        cout<< 1;
        int heightDiff = leftHeight - rightHeight;
        if (abs(heightDiff) > 1) return -1;
        else return (max(leftHeight,rightHeight)+1);
    }
};
```

###<a name= "111-minimum-depth-of-binary-tree"></a>111 Minimum Depth of Binary Tree
> Given a binary tree, find its minimum depth.

> The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.


***C++ Code***
```C++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root ==NULL) return 0;
        if (!root->left) return 1+minDepth(root->right);
        if (!root->right) return 1+minDepth(root->left);
        return min(minDepth(root->left),minDepth(root->right))+1;
    }
};
```

###<a name="153-find-minimum-in-rotated-sorted-array">153 Find Minimum in Rotated Sorted Array

> Suppose a sorted array is rotated at some pivot unknown to you beforehand.

> (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

> Find the minimum element.

> You may assume no duplicate exists in the array.

**Idea**

***C++ Code*** 
In this problem, there is only 1 rotation, so that there are only limited cases when we split the array using the mid-element:
 1. the right part is ordered (A[mid] < A[ed])
 2. the right  part is unordered (A[mid] > A[ed])
 Some might say that what about the left part of the array? Note that there is only 1 rotation, which indicates that if right part is unordered, the left part of array must be ordered.
为什么比较end呢？因为这是寻找最小值，如果比较start，发现左边有序，则去右边寻找突变时，可能忽视整个数列都是有序的，错过第一个最小数，因此注意：
- Find minimum in sorted array: compare ***mid*** and ***end***
- Find maximum in sorted array: compare ***mid*** and ***start***

```C++
class Solution {
public:
    int findMin(vector<int> &num) 
    {
        if (num.size()==1) return num[0];
        int low = 0, high = num.size()-1;
        while (low + 1 < high)
        {
            int mid = low + (high - low)/2;
            if (num[mid]<num[high]) high=mid;
            else low=mid;
        }
        if (num[low]>=num[low+1]) return num[low+1]; 
        else return num[low];
    }
};
```

###<a name="154-find-minimum-in-rotated-sorted-array-ii">153 Find Minimum in Rotated Sorted Array II
> Follow up for "Find Minimum in Rotated Sorted Array":

> What if duplicates are allowed?

> Would this affect the run-time complexity? How and why?

**Idea**

***C++ Code***
```C++
class Solution {
public:
    int findMin(vector<int>& nums) {
        if (nums.size()==1) return nums[0];
        int low = 0, high = (int)nums.size() - 1;
        while (low + 1 < high) {
            int mid = low + (high - low)/2;
            if (nums[mid] < nums[high]) high = mid;
            else if (nums[mid] > nums[high]) low = mid;
            else high--;
        }
        if (nums[low] >= nums[low + 1]) return nums[low+1];
        else return nums[low];
    }
};
```
###<a name="207-course-schedule"></a>207 Course Schedule
> There are a total of n courses you have to take, labeled from 0 to n - 1.

> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

> Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

> For example:

<pre>2, [[1,0]]</pre>
> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.

<pre>2, [[1,0],[0,1]]</pre>
> There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

***C++ Code***
```C++
class Solution {
public:
    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<vector<int>> topo(numCourses,vector<int>(0));
        vector<int> inDegree(numCourses,0);
        for (auto s:prerequisites) {
            topo[s.second].push_back(s.first);
            inDegree[s.first]++;
        }
        queue<int> q;
        for (int i = 0;i < numCourses;i++) {
            if (inDegree[i] == 0) q.push(i);
        }
        int count = 0;
        while (!q.empty()) {
            int temp = q.front();
            q.pop();
            count++;
            for (auto x:topo[temp]) {
                inDegree[x]--;
                if (inDegree[x] == 0) q.push(x);
            }
        }
        return count == numCourses;
    }
};
```

###<a name="210-course-schedule-ii"></a>207 Course Schedule II
> Store the sequence.

***C++***
```c++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {
        vector<int> result;
        if (numCourses <= 0) return result;
        vector<vector<int>> topo(numCourses, vector<int>(0));
        vector<int> inDegree(numCourses, 0);
        for (auto i : prerequisites) {
            topo[i.second].push_back(i.first);
            ++inDegree[i.first];
        }
        queue<int> q;
        for (int i = 0;i < numCourses;i++) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        int count = 0;
        while (!q.empty()) {
            int temp = q.front();
            ++count;
            result.push_back(temp);
            q.pop();
            for (int j: topo[temp]) {
                --inDegree[j];
                if (inDegree[j] == 0) q.push(j);
            }
        }
        vector<int> a;
        return count==numCourses?result:a;
    }
};
```


###<a name="216-combination-sum-iii"></a>216 Combination Sum III

> Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.

> Ensure that numbers within the set are sorted in ascending order.


> Example 1:

<pre>
Input: k = 3, n = 7

Output:

[[1,2,4]]
</pre>

> Example 2:

<pre>
Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]
</pre>

**Idea**

***C++ Code***
```C++
class Solution {
public:
    void combinationsHelper(vector<vector<int>> &result,vector<int> &line,int k, int target,int start) {
        if (line.size() == k && target == 0) {
            result.push_back(line);
            return;
        }
        for (int i = start;i <= 9;i++) {
            if (target>=0) {
                line.push_back(i);
                combinationsHelper(result,line,k,target - i,i+1);
                line.pop_back();
            }
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> result;
        vector<int> line;
        combinationsHelper(result,line,k,n,1);
        return result;
    }
};
```

###<a name="221-maximal-square"></a>221 Maximal Square
> Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area.

> For example, given the following matrix:

<pre>
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
</pre>

**Idea** 二维DP 比如 ["11","11"]得到4，而DP矩形里应该返回["11","12"]，意思是右下角表示之前累计的边长。

***C++ Code***
```C++
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() < 1 || matrix[0].size() < 1) return 0;
        vector<vector<int>> dp(matrix.size(),vector<int>(matrix[0].size(),0));
        int ret = 0;
        for (int i = 0;i < matrix.size();i++) {
            for (int j = 0;j < matrix[0].size();j++) {
                dp[i][j] = matrix[i][j] - '0';
                if (i > 0 && j > 0 && dp[i][j] == 1) {
                    dp[i][j] += min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j]));
                }
                ret = max(ret,dp[i][j]);
            }
        }
        return ret*ret;
    }
};
```

###<a name="226-invert-binary-tree"></a>226 Invert Binary Tree
> Invert a binary tree.
<pre>
     4
   /   \
  2     7
 / \   / \
1   3 6   9
</pre>
to
<pre>
     4
   /   \
  7     2
 / \   / \
9   6 3   1
</pre>

***C++ Code***
```C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        invertHelper(root);
        return root;
    }
    
    void invertHelper(TreeNode* root) {
        if (root == NULL) return;
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;
        invertHelper(root->left);
        invertHelper(root->right);
    }
};
```

###<a name="240-search-a-2d-matrix-ii"></a>240 Search a 2D Matrix II
> Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

> Integers in each row are sorted in ascending from left to right.

> Integers in each column are sorted in ascending from top to bottom.

> For example,

> Consider the following matrix:
<pre>
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
</pre>

> Given target = 5, return true.

> Given target = 20, return false.

***C++ Code***
```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int i = 0, j = matrix[0].size()-1; 
        while (i < matrix.size() && j >= 0) {
            if (matrix[i][j] == target) return true;
            else if (matrix[i][j] < target) i++;
            else j--;
        }
        return false;
    }
};
```
###<a name="241-different-ways-to-add-parentheses"></a>241 Different Ways to Add Parentheses
> Given a string of numbers and operators, return all possible results from computing all the different possible ways to group > numbers and operators. The valid operators are +, - and *.

***C++ Code***
```C++
class Solution {
    int compute(int a, int b, char sym) {
        if (sym == '+') return a+b;
        if (sym == '-') return a-b;
        if (sym == '*') return a*b;
        return 0;
    }
public:
    vector<int> diffWaysToCompute(string input) {
        vector<int> result;
        bool flag = false;
        for (int i = 0;i < input.size();i++) {
            if (input[i] == '+' || input[i] == '-' || input[i]== '*') {
                flag = true;
                vector<int> lefts = diffWaysToCompute(input.substr(0,i));
                vector<int> rights = diffWaysToCompute(input.substr(i+1,input.size()-1));
                for (int k = 0;k < lefts.size();k++) {
                    for (int l = 0;l < rights.size();l++) {
                        result.push_back(compute(lefts[k],rights[l],input[i]));
                    }
                }
            }
        }
        if(!flag) result.push_back(stoi(input));
        return result;
    }
};
```

###<a name="268-missing-number"></a>268 Missing Number
> Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.

> For example,

> Given nums = [0, 1, 3] return 2.

> ***Note:***

> Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?

**Idea** 

- Using Math, to sum the numbers, and delete them one by one.
- Using bit manipulation, it can avoid overflow. ***Optimal***
- Using extra spaces, like a array or hashmap.

***C++ Solution 1***
```C++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int sum = 0;
        for (auto s:nums) sum += s;
        return (nums.size()*(nums.size()+1))/2 - sum;
    }
};
```
***C++ Solution 2***
```C++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int ret = 0;
        for (int i = 0;i < nums.size();i++) {
            ret ^= nums[i];
            ret ^= i+1;
        }
        return ret;
    }
};
```



### Others

###<a name="1-fibonacci"></a>1 Fibonacci

***Recursive C++ Code***
```C++
int recursive(int x){
    if (x == 0) return 0;
    if (x == 1) return 1;
    cout << x << " ";
    return recursive(x-1) + recursive(x-2);
}
```
***Time:*** T(n)=T(n−1)+T(n−2)+Θ(1) ==> O(2^n)

***Space*** O(1)? O(2^n)? 

It should be O(n), as we should draw the recursion tree, we will find it may be O(2^n), but in the stack frame.
For example when Fib(2) = Fib(1) + Fib(0) done, the stack memory of Fib(1) and Fib(0) will return so the memory will pop back, then the maximum stack memory should be Fib(n-1) + Fib(n-2) + ... + Fib(1) = O(n);

***Recursive C++ using O(n)***
```C++
int fib(int term, int val = 1, int prev = 0)
{
    if(term == 0) return prev;
    if(term == 1) return val;
    return fib(term - 1, val+prev, val);
}
```


***Iterative C++ Code***
```C++
int iterative(int n) {
    vector<int> dp;
    dp.push_back(0);
    dp.push_back(1);
    for (int i = 2;i <= n;i++) {
        dp.push_back(dp[i-1] + dp[i-2]);
    }
    return dp[n];
}
```

***Time:*** O(n)

***Space:*** O(n)

###<a name="2-binary-search-template"></a>2 Binary Search Template

***C++ Code*** 天真模版
```C++
bool binarySearch(vector<int>& nums,int target) {
    int low = 0, high = (int)nums.size() - 1;
    while (low <= high) {
        int mid = low + ((high - low)>>1);
        if (target == nums[mid]) return true;
        else if (target > nums[mid]) low = mid + 1;
        else high = mid - 1;
    }
    return false;
}
```

***C++ Code***万能模版
```C++
int binarySearch(vector<int>& nums,int target) {
    int low = 0, high = (int)nums.size() - 1;
    while (low + 1 < high) {
        int mid = low + ((high - low)>>1);
        if (target == nums[mid]) return mid;
        else if (target > nums[mid]) low = mid;
        else high = mid;
    }
    if (nums[low] == target) return low;
    if (nums[high] == target) return high;
    return -1;
}
```

###<a name = "3-merge-sort"></a>3 Merge Sort

***C++ Code***
```C++

void merge(vector<int> &a,int low, int high, int mid) {
    {
        int i, j, k, c[(int)a.size()-1];
        i = low;
        k = low;
        j = mid + 1;
        while (i <= mid && j <= high)
        {
            if (a[i] < a[j])
            {
                c[k] = a[i];
                k++;
                i++;
            }
            else
            {
                c[k] = a[j];
                k++;
                j++;
            }
        }
        while (i <= mid)
        {
            c[k] = a[i];
            k++;
            i++;
        }
        while (j <= high)
        {
            c[k] = a[j];
            k++;
            j++;
        }
        for (i = low; i < k; i++)
        {
            a[i] = c[i];
        }
    }
    
}
void mergesort(vector<int> &nums, int low, int high) {
    if (low < high) {
        int mid = low + (high - low)/2;
        mergesort(nums, low, mid);
        mergesort(nums, mid+1, high);
        merge(nums,low,high,mid);
    }
    return;
}
```

###<a name="4-quick-sort"></a>4 Quick Sort

***C++ Code***
```C++
void quickSort(int arr[], int left, int right) {
    int i = left, j = right;
    int pivot = arr[(left + right) / 2];
    
    /* partition */
    while (i <= j) {
        while (arr[i] < pivot)
            i++;
        while (arr[j] > pivot)
            j--;
        if (i <= j) {
            swap(arr[i],arr[j]);
            i++;
            j--;
        }
    };
    
    /* recursion */
    if (left < j)
        quickSort(arr, left, j);
    if (i < right)
        quickSort(arr, i, right);
}
```
